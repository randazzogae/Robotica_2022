:- module(best_first_search).
:- export bfs_minimize / 3.
:- tool(bfs_minimize / 3, bfs_minimize_ / 4).
:- export bfs_minimize / 4.
:- tool(bfs_minimize / 4, bfs_minimize_ / 5).
:- comment(categories, ["Algorithms"]).
:- comment(summary, "Best first search").
:- comment(author, "Joachim Schimpf, Monash University").
:- comment(date, "$Date: 2016/08/12 10:57:29 $").
:- comment(index, ["branch-and-bound", "search", "best-first search"]).
:- comment(bfs_minimize / 4, [summary : "Minimization using best-first search", args : ["Vars" : "Array of problem variables", "Cost" : "Cost variable", "Heur" : "Heuristic variable", "Separator" : "Separator goal"], desc : html("<P>\n        Cost is the problem's cost variable: whenever we have a solution,\n        Cost must be instantiated and represent the cost of the solution.\n        At all other times, Cost's lower bound is a lower bound on the\n        cost in the current state. If Cost is not updated by propagation,\n        it can be passed as an argument into the separation goal, which\n        can then instantiate it to the solution cost, resp. the lower\n        bound of the cost of a branch.\n</P><P>\n        Heur is the problem's heuristic variable: its lower bound is\n        taken as an estimate for the cost that a solution derived from\n        the current computation state might have. Like Cost, it can either\n        be computed by propagation, or the separation goal can instantiate\n        it explicitly for every branch. The heuristic value should always\n        lie between the bounds of the cost variable. In the simplest case,\n        Heur can be the same as Cost.\n</P><P>\n        The Separator goal has two purposes: to detect when we have a\n\tsolution, and to nondeterministically generate branches (together\n\twith their cost bound and a heuristic estimate of their quality).\n        The separation goal has user-defined arguments, except that it\n        must return its results in the last argument.  It will be called\n        with the instantiation state corresponding to the current search\n        node, and should succeed once for every branch, returning:\n\t<DL>\n        <DT><STRONG>true</STRONG></DT><DD>\n\t    iff the node is already a solution without further branching.\n            Cost must then be instantiated to the solution's cost.\n            Heur is ignored in this case and can remain undefined.\n\n        <DT><STRONG>I-C</STRONG></DT><DD>\n\t    for a branch that imposes constraint C onto variable X[I].\n\t    Cost must have a lower bound corresponding to this choice,\n\t    and Heur must a have a lower bound (or be instantiated to)\n\t    a heuristics estimate for a solution cost that this branch\n\t    could lead to.  Heur should lie between the cost lower and\n\t    upper bounds (if it is outside, it will be rounded into\n\t    this interval).\n\t</DL>\n</P><P>\n\tThe branching constraint descriptor I-C can have the following forms:\n<PRE>\t\n\tI-Val        imposes the constraint X[I]=Val (Val is atomic)\n\tI-ge(Val)    imposes lower numeric bound Val onto X[I]\n\tI-le(Val)    imposes upper numeric bound Val onto X[I]\n\tI-ne(Val)    imposes the constraint X[I] #\\= Val\n\tI-lt(Val)    imposes the constraint X[I] #< Val\n\tI-gt(Val)    imposes the constraint X[I] #> Val\n\t(C1,C2)      imposes conjunction of descriptor C1 and descriptor C2\n</PRE>\t\n</P>"), eg : "\n    % A sample separation goal.\n    % The first argument is expected to be an Index-Variable list\n    % of the problem variables.  The separation result(s) are\n    % returned in the last argument.  The cost variable is expected\n    % to be affected by propagation following indomain(X).\n\n\tseparate([], true).\n\tseparate(IXs, IX) :-\n\t    delete(I-X, IXs, IXs1, 2, first_fail),\n\t    ( nonvar(X) -> separate(IXs1, IX)\n\t    ; IX=I-X, indomain(X)\n\t    ).\n\n    % Sample call:\n    ?- model(XArr),\n       ( foreacharg(X,XArr,I), foreach(I-X,IXs) do true ),\n       bfs_minimize(XArr, Cost, Cost, separate(IXs,_)).\n\n\n    % A separation goal that computes a more elaborate heuristic,\n    % based on the number of remaining uninstantiated variables.\n\n\tseparate([], _, _, true).\n\tseparate(IXs, Cost, Est, IX) :-\n\t    delete(I-X, IXs, IXs1, 2, first_fail),\n\t    ( nonvar(X) -> separate(IXs1, Cost, Est, IX)\n\t    ; IX=I-X,\n\t      indomain(X),\n\t      term_variables(IXs1,Vs),\n\t      get_var_bounds(Cost, Lwb, Upb),\n\t      Est is Upb - (Upb-Lwb)/(length(Vs)+1)\n\t    ).\n\n    % Sample call:\n    ?- model(XArr),\n       ( foreacharg(X,XArr,I), foreach(I-X,IXs) do true ),\n       bfs_minimize(XArr, Cost, Heur, separate(IXs,Cost,Heur,_)).\n\n    "]).
