:- module(error).
:- export instantiation_error / 1.
:- export uninstantiation_error / 1.
:- export type_error / 2.
:- export domain_error / 2.
:- export existence_error / 2.
:- export permission_error / 3.
:- export representation_error / 1.
:- export evaluation_error / 1.
:- export resource_error / 1.
:- export must_be / 2.
:- comment(categories, ["Programming Utilities"]).
:- comment(summary, "Utilities for argument type testing and error generation").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Coninfer Ltd").
:- comment(date, '$Date: 2017/09/03 00:50:40 $').
:- comment(desc, html("<P>\n    This library is modelled after SWI-Prolog's library(error) and provides\n    facilities to simplify the raising of ISO-Prolog conforming exceptions,\n    and testing argument types and domains.\n</P>")).
:- comment(domain_error / 2, [args : ["Domain" : "Specification of the expected domain", "Culprit" : "The term that caused the error"], summary : "throw error(domain_error(Domain,Culprit), _)", eg : "domain_error(non_empty_list, [])"]).
:- comment(evaluation_error / 1, [args : ["Reason" : "Name of the exceptional result"], summary : "throw error(evaluation_error(Reason), _)", desc : html("<P>\n    ISO-defined values for Reason: float_overflow, int_overflow, undefined,\n    underflow, zero_divisor.\n    </P>")]).
:- comment(existence_error / 2, [args : ["ObjectType" : "Specification of the expected object type", "Culprit" : "The non-existing object"], summary : "throw error(existence_error(ObjectType,Culprit), _)", eg : "existence_error(procedure, ex_nihilo/0)", desc : html("<P>\n    ISO-defined values for ObjectType: procedure, source_sink, stream.\n    </P>")]).
:- comment(instantiation_error / 1, [args : ["Culprit" : "The term that caused the error (ignored)"], summary : "throw error(instantiation_error, _)"]).
:- comment(must_be / 2, [summary : "Test a term for an expected type and throw an error if it does not match", amode : (must_be(+, ?) is det), args : ["Type" : "The name or descriptor of the expected type", "Term" : "The term to be tested"], see_also : [type_of / 2], desc : html("<P>\n    This predicate performs a runtime type test and throws an error if the\n    test fails.  The supported type descriptors include:\n    <DL>\n    <DT>acyclic</DT><DD>\n    \tan acyclic term, see acyclic/1</DD>\n    <DT>array</DT><DD>\n    \tan array, i.e. a structure with functor []/N</DD>\n    <DT>atom</DT><DD>\n    \tan atom, see atom/1</DD>\n    <DT>atomic</DT><DD>\n    \tnot a compound term, see atomic/1</DD>\n    <DT>between(L,H)</DT><DD>\n    \tnumber between L and H, must be integer if L,H are integer</DD>\n    <DT>boolean</DT><DD>\n    \tone of the atoms 'true' or 'false'</DD>\n    <DT>breal</DT><DD>\n    \ta bounded real, see breal/1</DD>\n    <DT>callable</DT><DD>\n    \tan atom or compound term, see callable/1</DD>\n    <DT>char</DT><DD>\n    \ta single-character atom</DD>\n    <DT>chars</DT><DD>\n    \ta list of single-character atoms</DD>\n    <DT>code</DT><DD>\n    \tan integer character code</DD>\n    <DT>codes</DT><DD>\n    \ta list of integer character codes</DD>\n    <DT>compound</DT><DD>\n    \ta compound term (including list and array)</DD>\n    <DT>cyclic</DT><DD>\n    \ta cyclic term, see cyclic/1</DD>\n    <DT>encoding</DT><DD>\n    \tan atom specifying a character encoding, such as 'iso_latin_1'</DD>\n    <DT>float</DT><DD>\n    \ta floating point number, see float/2</DD>\n    <DT>ground</DT><DD>\n    \ta ground (i.e. fully instantiated) term, see ground/1</DD>\n    <DT>handle</DT><DD>\n    \ta handle, see is_handle/1</DD>\n    <DT>handle(Class)</DT><DD>\n    \ta handle of the given class, see is_handle/2</DD>\n    <DT>list</DT><DD>\n    \ta proper list</DD>\n    <DT>list(Type)</DT><DD>\n    \ta proper list with elements of Type</DD>\n    <DT>list_or_partial_list</DT><DD>\n    \ta proper or partial (i.e. ending in a variable) list</DD>\n    <DT>negative_integer</DT><DD>\n    \tinteger less than zero</DD>\n    <DT>nonneg</DT><DD>\n    \tinteger greater or equal to zero</DD>\n    <DT>nonvar</DT><DD>\n\tany non-variables, see nonvar/1</DD>\n    <DT>number</DT><DD>\n    \tany number, see number/1</DD>\n    <DT>oneof(Values)</DT><DD>\n    \ta member of the list Values</DD>\n    <DT>positive_integer</DT><DD>\n    \tinteger greater than zero</DD>\n    <DT>rational</DT><DD>\n    \ta rational number, see rational/1</DD>\n    <DT>real</DT><DD>\n    \ta float or breal number, see real/1</DD>\n    <DT>string</DT><DD>\n    \ta string, see string/1</DD>\n    <DT>text</DT><DD>\n    \tstring, atom, chars or codes</DD>\n    <DT>var</DT><DD>\n    \tan (uninstantiated) variable</DD>\n    </DL>\n    Many of these correspond to a simple type testing predicate. Note that\n    tests that require traversal of compound terms (such as 'cyclic' or\n    'list') can be expensive.\n    </P><P>\n    If Term does not satisfy the expected type, one of the following\n    error terms is thrown, as appropriate:\n    <DL>\n    <DT>error(instantiation_error, _)</DT><DD>\n    \tan variable was detected where an instantiated term was expected</DD>\n    <DT>error(uninstantiation_error(Term), _)</DT><DD>\n    \tan instantiated term was detected where a variable was expected</DD>\n    <DT>error(type_error(Type,Term), _)</DT><DD>\n    \tTerm is not of type Type</DD>\n    <DT>error(domain_error(Type,Term), _)</DT><DD>\n    \tTerm is of the right general type but has an unacceptable value</DD>\n    </DL>\n    A domain error is used instead of a type error when a number is\n    outside an expected range, or an atom is not in the expected set.\n    </P><P>\n    If Type is not one of the recognized types, it is assumed that the type\n    test failed, and one of the following error terms is thrown:\n    <DL>\n    <DT>error(instantiation_error, _)</DT><DD>\n    \tif Term was a variable</DD>\n    <DT>error(type_error(Type,Term), _)</DT><DD>\n    \totherwise</DD>\n    </DL>\n    </P>")]).
:- comment(permission_error / 3, [args : ["Operation" : "Name of the faild operation", "Permission" : "Name of the violated permission", "Culprit" : "The term that caused the problem"], summary : "throw error(permission_error(Operation,Permission,Culprit), _)", desc : html("<P>\n    ISO-defined values for Operation: access, create, input, modify,\n    open, output, reposition.\n    ISO-defined values for Permission: binary_stream, flag, operator,\n    past_end_of_stream, private_procedure, static_procedure, source_sink,\n    stream, text_stream, open, output, reposition.\n    </P>"), eg : "permission_error(open, source_sink, '/etc/shadow')"]).
:- comment(representation_error / 1, [args : ["Reason" : "Name of the restriction that caused the problem"], summary : "throw error(representation_error(Reason), _)", desc : html("<P>\n    ISO-defined values for Reason: character, character_code,\n    in_character_code, max_arity, max_integer, min_integer.\n    </P>")]).
:- comment(resource_error / 1, [args : ["Resource" : "Name of the exhausted resource"], summary : "throw error(resource_error(Resource), _)"]).
:- comment(type_error / 2, [args : ["Type" : "Specification of the expected type", "Culprit" : "The term that caused the error"], summary : "throw error(type_error(Type,Culprit), _)", eg : "type_error(list, [foo|bar])"]).
:- comment(uninstantiation_error / 1, [args : ["Culprit" : "The term that caused the error"], summary : "throw error(uninstantiation_error(Culprit), _)"]).
