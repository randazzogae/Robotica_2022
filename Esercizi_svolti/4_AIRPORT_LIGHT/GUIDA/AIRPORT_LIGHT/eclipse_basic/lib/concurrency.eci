:- module(concurrency).
:- export engines / 0.
:- export exit_all / 1.
:- export concurrent / 3.
:- tool(concurrent / 3, concurrent_ / 4).
:- export concurrent_or / 3.
:- tool(concurrent_or / 3, concurrent_or_ / 4).
:- comment(categories, ["Programming Utilities", "Techniques"]).
:- comment(summary, "Engine utilities and higher-level threading functionality").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Coninfer Ltd").
:- comment(date, '$Date: 2017/09/03 00:50:40 $').
:- comment(desc, html("<P>\n</P>\n")).
:- comment(concurrent / 3, [amode : (concurrent(+, +, +) is semidet), args : ["MaxThreads" : "A positive integer", "Goals" : "A list of callable terms", "Options" : "A list of option terms"], summary : "Execute goals concurrently, using multiple threads", desc : html("<P>\n    Execute the goals in Goals concurrently/in parallel.  Succeed once all\n    goals have succeeded.  Only the first solution for each goal is computed.\n    Fail (or throw) as soon as one of the goals is found to fail (or throw).\n    </P><P>\n    Operationally, a copy of each goal is executed in an engine.  Once all\n    goals have succeeded, all goals are simultaneously instantiated to their\n    first solutions.  The equivalent sequential operation could be written as:\n    <PRE>\n    concurrent(1, Goals, _) :-\n\t( foreach(Goal,Goals), foreach(Copy,Copies) do\n\t    copy_term(Goal, Copy),\n\t    once(Copy)\n\t),\n\tGoals = Copies.\n    </PRE>\n    A maximum of MaxThreads engines is used to work in parallel.  If there\n    are more goals than engines, engines are reused as they become available.\n    Use get_flag(cpu_count,N) to obtain the number of processors on the\n    machine, which might be a good value for MaxThreads.  If some goals are\n    expected to fail, a higher number of threads can be advantageous for\n    finding failures earlier.\n    </P><P>\n    The Options argument can be used to pass extra options for the creation\n    of the worker engines.  In particular, the stack size options local(KBytes)\n    and global(KBytes) can be used to limit their memory consumption.\n    </P><P>\n    Due to the overheads of engine creation and destruction, this predicate\n    is only useful for sufficiently long-running goals.\n    </P>"), see_also : [concurrent_or / 3, engine_create / 2]]).
:- comment(concurrent_or / 3, [amode : (concurrent_or(+, +, +) is semidet), args : ["MaxThreads" : "A positive integer", "Goals" : "A list of callable terms", "Options" : "A list of option terms"], summary : "Execute alternative goals concurrently, using multiple threads", desc : html("<P>\n    Execute the goals in Goals concurrently/in parallel.  Succeed once the\n    first goal succeeds, and use this goal's solution.  Only one solution\n    is computed.  Fails if none of the goals has a solution.  Operationally,\n    a copy of each goal is executed in an engine.  The first goal to succeed\n    is chosen as the solution, and all others are aborted and ignored.\n    The equivalent sequential operation could be written as:\n    <PRE>\n    concurrent_or(1, Goals, _) :-\n\tmember(Goal, Goals),\n\tcopy_term(Goal, Copy),\n\tcall(Copy),\n\t!, Goal = Copy.\n    </PRE>\n    A maximum of MaxThreads engines is used to work in parallel.  If there\n    are more goals than engines, engines are reused as they become available.\n    </P><P>\n    Use get_flag(cpu_count,N) to obtain the number of processors on the\n    machine, which might be a good value for MaxThreads.  If some solutions\n    are expected to be easier to find than others, a higher number of threads\n    (up to one thread per goal) can be advantageous for finding these easy\n    solutions earlier.  The latter is essentially a breadth-first-search.\n    </P><P>\n    The Options argument can be used to pass extra options for the creation\n    of the worker engines.  In particular, the stack size options local(KBytes)\n    and global(KBytes) can be used to limit their memory consumption.\n    </P><P>\n    Due to the overheads of engine creation and destruction, this predicate\n    is only useful for sufficiently long-running goals.\n    </P>"), see_also : [concurrent / 3, engine_create / 2]]).
:- comment(engines / 0, [summary : "Print the currently known engines and their properties (to log_output)", see_also : [engine_create / 2, exit_all / 1]]).
:- comment(exit_all / 1, [amode : exit_all(+), args : ["ExitCode" : "A small integer"], summary : "Post exit(ExitCode) requests to all engines (except self)", see_also : [exit / 1]]).
