:- module(threads).
:- export is_thread / 1.
:- export thread_default / 1.
:- export thread_set_default / 1.
:- export thread_create / 3.
:- tool(thread_create / 3, thread_create_ / 4).
:- export thread_create / 2.
:- tool(thread_create / 2, thread_create_ / 3).
:- export thread_create / 1.
:- tool(thread_create / 1, thread_create_ / 2).
:- export thread_join / 2.
:- export thread_exit / 1.
:- export thread_self / 1.
:- export thread_sleep / 1.
:- export thread_signal / 2.
:- tool(thread_signal / 2, thread_signal_ / 3).
:- export thread_cancel / 1.
:- export thread_detach / 1.
:- export thread_property / 2.
:- export message_queue_create / 1.
:- export message_queue_create / 2.
:- export message_queue_destroy / 1.
:- export thread_send_message / 2.
:- export thread_get_message / 2.
:- export thread_peek_message / 2.
:- export thread_send_message / 1.
:- export thread_get_message / 1.
:- export thread_peek_message / 1.
:- export mutex_create / 2.
:- export mutex_create / 1.
:- export mutex_destroy / 1.
:- export with_mutex / 2.
:- export initialization(import with_mutex / 2 from threads).
:- tool(with_mutex / 2, with_mutex_ / 3).
:- comment(categories, ["Compatibility"]).
:- comment(summary, "Prolog thread API (ISO/IEC Draft TR 13211-5:2007)").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Coninfer Ltd").
:- comment(date, '$Date: 2017/09/03 00:50:40 $').
:- comment(desc, html("<P>\n    This library implements most of the functionality described in\n    the Draft Technical Recommendation ISO/IEC DTR 13211-5:2007\n    'Prolog Multi-threading Support' (<A HREF=\"http://logtalk.org/plstd/threads.pdf\">http://logtalk.org/plstd/threads.pdf</A>),\n    which is also the basis for multi-threading functionality in a\n    number of Prolog systems (SWI, XSB, YAP).  To clarify notation,\n    we will refer to\n<UL>\n    <LI>this library's 'threads' as <EM>DTR-threads</EM></LI>\n    <LI>this library's 'queues' as <EM>DTR-queues</EM></LI>\n</UL>\n</P><P>\n    Note that this library is just a thin layer on top of ECLiPSe's\n    more general 'engine' functionality.  The main differences are:\n<UL>\n    <LI><EM>DTR-threads</EM> are implemented as <EM>ECLiPSe engines</EM>, and <EM>DTR-queues</EM> are\n      implemented as <EM>ECLiPSe records</EM>.  While this in principle allows the\n      mixing of ECLiPSe's native engine-API and this library's API, in the\n      interest of readable code, programmers should commit to one of the APIs.\n</LI>\n    <LI>An <EM>ECLiPSe engine</EM> can optionally be associated with an\n      operating system thread, while <EM>DTR-threads</EM> are\n      always associated with an operating system thread.\n</LI>\n    <LI>An <EM>ECLiPSe engine</EM> can stop (with success, failure, etc),\n      retain its state, and later be resumed.  In contrast, <EM>DTR-threads</EM>\n      execute a single goal, are terminated as soon as this goal succeeds\n      or fails or exits, and disappear when the thread is joined.\n</LI>\n    <LI>Although this library implements alias names for <EM>DTR-threads</EM>\n      and <EM>queues</EM>, they should be used sparingly because they prevent\n      automatic garbage collection of the named object.  For efficiency\n      reasons, only one alias per item is supported.\n</LI>\n</UL>\n</P>\n")).
:- comment(is_thread / 1, [amode : is_thread(?), args : ["Term" : "Term to be tested"], summary : "Succeeds if Term is a DTR-thread alias or thread/engine handle", see_also : [is_handle / 2]]).
:- comment(message_queue_create / 1, [amode : (message_queue_create(-) is det), args : ["Queue" : "Output: queue handle"], summary : "Creates a DTR message queue", desc : html("<P>\n    Equivalent to message_queue_create(Queue,[]) and record_create(Queue).\n</P>"), see_also : [record_create / 1, message_queue_create / 2]]).
:- comment(message_queue_create / 2, [amode : (message_queue_create(-, ++) is det), args : ["Queue" : "Output: queue handle", "Options" : "A list of Options"], summary : "Creates a DTR message queue", desc : html("<P>\n    Creates a message queue with options.  The only supported option\n    is alias(Name).  Otherwise equivalent to record_create(Queue).\n</P>"), see_also : [record_create / 1, message_queue_create / 1]]).
:- comment(message_queue_destroy / 1, [amode : (message_queue_destroy(+) is det), args : ["Queue" : "Queue handle or alias"], summary : "Destroy a DTR message queue", see_also : [message_queue_create / 1, message_queue_create / 2]]).
:- comment(mutex_create / 1, [amode : (mutex_create(?) is det), args : ["Mutex" : "Mutex handle (output) or alias"], summary : "Creates a mutual exclusion object with alias", see_also : [mutex_create / 2, mutex_destroy / 1, with_mutex / 2]]).
:- comment(mutex_create / 2, [amode : (mutex_create(-, ++) is det), args : ["Mutex" : "Output: mutex handle", "Options" : "A list of Options"], summary : "Creates a mutual exclusion object", see_also : [mutex_create / 1, mutex_destroy / 1, with_mutex / 2]]).
:- comment(mutex_destroy / 1, [amode : (mutex_destroy(+) is det), args : ["Mutex" : "Mutex handle or alias"], summary : "Destroys a mutual exclusion object", see_also : [mutex_create / 1, mutex_create / 2, with_mutex / 2]]).
:- comment(thread_cancel / 1, [amode : (thread_cancel(+) is det), args : ["Thread" : "A DTR-thread handle or alias"], summary : "Makes Thread exit at the next opportunity", desc : html("<P>\n    Equivalent to engine_post(Thread, exit(3)) plus deletion of\n    Thread's alias.\n</P>"), see_also : [engine_post / 2]]).
:- comment(thread_create / 1, [amode : (thread_create(+) is det), args : ["Goal" : "A callable term"], summary : "Create a detached DTR-thread with default options", desc : html("<P>\n    Equivalent to thread_create(Goal, _, [detached(true)]).\n</P>"), see_also : [thread_create / 3, engine_create / 2]]).
:- comment(thread_create / 2, [amode : (thread_create(+, -) is det), args : ["Goal" : "A callable term", "Thread" : "Output: a handle for the created DTR-thread"], summary : "Create a DTR-thread with default options", desc : html("<P>\n    Equivalent to thread_create(Goal, Thread, []).\n</P>"), see_also : [thread_create / 3, engine_create / 2]]).
:- comment(thread_create / 3, [amode : (thread_create(+, -, +) is det), args : ["Goal" : "A callable term", "Thread" : "Output: a handle for the created DTR-thread", "Options" : "A list of option terms"], summary : "Create a DTR-thread", desc : html("<P>\n    Create a thread (according to DTR 13211-5), and start it by executing\n    (a copy of) Goal.  The following options are supported:\n    <DL>\n    <DT><B>alias(Name)</B></DT><DD>\n        make the DTR-thread available under the alias Name (an atom).\n    </DD>\n    <DT><B>detached(Bool)</B></DT><DD>\n        when true, free all DTR-thread resources on completion of Goal, and\n\tdo not wait for thread_join/2\n    </DD>\n    <DT><B>all options of engine_create/2</B></DT><DD>\n    </DD>\n    </DL>\n    </P><P>\n    Relationship to ECLiPSe engines: a DTR-thread is an ECLiPSe engine\n    associated with a record queue. So, thread_create/3 is essentially a\n    combination of engine_create/2, engine_resume_thread/2 and record_create/1.\n    </P>"), see_also : [engine_create / 2, engine_resume_thread / 2, record_create / 1]]).
:- comment(thread_default / 1, [amode : (thread_default(+) is det), amode : (thread_default(-) is multi), args : ["Option" : "A term with arity 1, or variable"], summary : "Get default options for thread/engine creation", desc : html("Accesses the default thread/engine creation options:\n    local(KBytes), global(KBytes) and detached(Bool).\n    "), eg : "\n    % This predicate is defined as:\n    thread_default(local(KB))  :- get_flag(default_localsize,  KB).\n    thread_default(global(KB)) :- get_flag(default_globalsize, KB).\n    thread_default(detached(false)).\n    ", see_also : [thread_create / 2, thread_property / 2, engine_create / 2, get_flag / 2]]).
:- comment(thread_detach / 1, [amode : (thread_detach(+) is det), args : ["Thread" : "A DTR-thread alias or handle"], summary : "Thread ", see_also : [engine_post / 2]]).
:- comment(thread_exit / 1, [amode : thread_exit(+), args : ["Term" : "A term"], summary : "Exit the executing DTR-thread with status exited(Term)", desc : html("<P>\n    This compatibility predicate executes exit(3) and stores Term such\n    that the result status exited(Term) can be retrieved via thread_join/2\n    or thread_property/2.\n</P>"), see_also : [exit / 1, thread_join / 2, thread_property / 2]]).
:- comment(thread_get_message / 1, [amode : (thread_get_message(?) is det), args : ["Message" : "Message term, possibly partially instantiated"], summary : "Wait for and remove a message from the calling DTR-thread's message queue", see_also : [thread_get_message / 2]]).
:- comment(thread_get_message / 2, [amode : (thread_get_message(+, ?) is det), args : ["Queue" : "A DTR-thread or DTR-queue handle or alias", "Message" : "Message term, possibly partially instantiated"], summary : "Wait for and remove a message from Queue", desc : html("<P>\n    Waits until Queue contains an entry that unifies with Message,\n    then removes and unifies this message with Message.\n</P><P>\n    Essentially equivalent to record_wait_remove/3.\n</P>"), see_also : [record_wait_remove / 3, message_queue_create / 2]]).
:- comment(thread_join / 2, [amode : (thread_join(+, -) is det), args : ["Thread" : "A DTR-thread alias or handle", "Status" : "Output: result status"], summary : "Wait for termination of Thread", desc : html("<P>\n    Block until Thread terminates, and unify Status with its result status.\n    For the possible status values, see get_engine_property/3, with the\n    difference that here exited(Term) may contain an arbitrary term.\n</P><P>\n    After this call, the DTR-thread is destroyed and its handles and alias\n    are invalid.\n</P>"), see_also : [engine_join / 3, get_engine_property / 3, thread_create / 3]]).
:- comment(thread_peek_message / 1, [amode : (thread_peek_message(-) is det), args : ["Message" : "Message term, possibly partially instantiated"], summary : "Check for Message in the calling DTR-thread's message queue", see_also : [thread_peek_message / 2]]).
:- comment(thread_peek_message / 2, [amode : (thread_peek_message(+, -) is det), args : ["Queue" : "A DTR-thread or DTR-queue handle or alias", "Message" : "Message term, possibly partially instantiated"], summary : "Check for Message in Queue", desc : html("<P>\n    Unifies Message with (a copy of) an entry in Queue, if possible.\n</P><P>\n    Essentially equivalent to recorded/2.\n</P>"), see_also : [record_wait_remove / 3, message_queue_create / 2]]).
:- comment(thread_property / 2, [amode : (thread_property(-, -) is multi), amode : (thread_property(+, -) is multi), amode : (thread_property(+, ++) is semidet), args : ["Thread" : "A thread/engine handle or DTR-thread alias, or variable", "Property" : "Variable or compound term"], summary : "Enumerates threads and their properties", desc : html("<P>\n    If Thread is a thread/engine handle, enumerates the thread/engine's\n    properties and unifies them with Property.  If Thread is a variable,\n    enumerates all currently existing thread/engines  and their properties.\n    The properties are as defined in get_engine_property/3, plus the\n    alias(Name) option from thread_create/3.\n</P>"), see_also : [get_engine_property / 3, thread_create / 3]]).
:- comment(thread_self / 1, [amode : (thread_self(-) is det), amode : (thread_self(+) is semidet), args : ["Thread" : "A variable, DTR-thread alias or thread/engine handle"], summary : "True if Thread is the calling DTR-thread", desc : html("<P>\n    If Thread is uninstantiated, it is unified with a thread/engine handle\n    for the calling thread.  If Thread is a DTR-thread alias or a thread/engine\n    handle for the calling thread, the predicate succeeds, otherwise fails.\n</P><P>\n    Apart from alias handling, this is the same as engine_self/1.\n</P>"), see_also : [engine_self / 1]]).
:- comment(thread_send_message / 1, [amode : (thread_send_message(?) is det), args : ["Message" : "Any term"], summary : "Sends a message via the calling DTR-thread's message queue", see_also : [thread_send_message / 2]]).
:- comment(thread_send_message / 2, [amode : (thread_send_message(+, ?) is det), args : ["Queue" : "A DTR-thread or DTR-queue handle or alias", "Message" : "Any term"], summary : "Sends a message via Queue", desc : html("<P>\n    Essentially equivalent to record_wait_append4/4.\n</P>"), see_also : [record_wait_append / 4, message_queue_create / 2]]).
:- comment(thread_set_default / 1, [amode : (thread_set_default(++) is det), args : ["Option" : "A thread-option term"], summary : "Set default options for thread/engine creation", desc : html("Sets default thread/engine creation options.\n    The supported options are:\n<DL>\n    <DT>local(KBytes)</DT>\n        <DD>Set size of local/control stack in kBytes.\n\tEquivalent to set_flag(default_localsize, kBytes).</DD>\n    <DT>global(KBytes)</DT>\n        <DD>Set size of global/trail stack in kBytes.\n\tEquivalent to set_flag(default_globalsize, kBytes).</DD>\n</DL>\n    "), see_also : [thread_create / 2, engine_create / 2, set_flag / 2]]).
:- comment(thread_signal / 2, [amode : (thread_signal(+, +) is det), args : ["Thread" : "A DTR-thread handle or alias", "Goal" : "A callable term"], summary : "Makes Thread execute Goal at the next opportunity", desc : html("<P>\n    Equivalent to engine_post(Thread, Goal).\n</P>"), see_also : [engine_post / 2]]).
:- comment(thread_sleep / 1, [amode : (thread_sleep(+) is det), args : ["Seconds" : "A float or integer"], summary : "Suspends the calling thread/engine for Seconds seconds", desc : html("<P>\n    Equivalent to sleep(Seconds).\n</P>"), see_also : [sleep / 1]]).
:- comment(with_mutex / 2, [amode : with_mutex(+, +), args : ["Mutex" : "Mutex handle or alias", "Goal" : "A callable term"], summary : "Equivalent to once(Goal) but with mutual exclusion", desc : html("<P>\n    Equivalent to the with_mutex/2 built-in predicate, but also accepts\n    an atomic mutex alias.\n</P>"), see_also : [mutex_create / 1, mutex_create / 2, _274538 : with_mutex / 2]]).
