:- module(branch_and_bound).
:- export bb_min / 3.
:- export bb_min_cost / 4.
:- export bb_min / 6.
:- export minimize / 2.
:- export bb_init / 2.
:- export bb_cost / 2.
:- export bb_solution / 2.
:- export bb_finish / 1.
:- export bb_probe / 7.
:- export struct(bb_options(strategy, from, to, delta, factor, timeout, probe_timeout, solutions, report_success, report_failure, report_timeout)).
:- tool(minimize / 2, minimize / 3).
:- tool(bb_min / 3, bb_min / 4).
:- tool(bb_min_cost / 4, bb_min_cost_ / 5).
:- tool(bb_min / 6, bb_min / 7).
:- comment(categories, ["Algorithms"]).
:- comment(summary, "Generic branch-and-bound optimization").
:- comment(copyright, "Cisco Systems, Inc").
:- comment(author, "Joachim Schimpf, Vassilis Liatsos, IC-Parc, Imperial College, London").
:- comment(date, "$Date: 2015/04/04 22:05:50 $").
:- comment(index, ["branch-and-bound", "dichotomic search", "optimization"]).
:- comment(desc, html("<P>\n    This is a solver-independent library implementing branch-and-bound\n    optimization. It can be used with any nondeterministic search routine\n    that instantiates a cost variable when a solution is found. The cost\n    variable can be an arbitrary numerical domain variable or even a\n    simple domain-less Prolog variable.\n</P><P>\n    The main primitive is bb_min/3.  Assume we have the following\n    collection of facts:\n<PRE>\n        % item(Food, Calories, Price)\n        item(bread,  500, 1.50).\n        item(eggs,   600, 1.99).\n        item(milk,   400, 0.99).\n        item(apples, 200, 1.39).\n        item(butter, 800, 1.89).\n</PRE>\n   Then we can find a minimum-calorie solution as follows:\n<PRE>\n        ?- bb_min(item(Food,Cal,Price), Cal, _).\n        Found a solution with cost 500\n        Found a solution with cost 400\n        Found a solution with cost 200\n        Found no solution with cost -1.0Inf .. 199\n\n        Food = apples\n        Cal = 200\n        Price = 1.39\n        Yes (0.00s cpu)\n</PRE>\n    In this example, the item/3 predicate serves as a nondeterministic\n    generator of solutions with different values for the variable Cal,\n    which we have chosen as our cost variable.  As can be seen from the\n    progress messages, the optimization procedure registers increasingly\n    good solutions (i.e. solutions with smaller cost), and finally delivers\n    the minimum-cost solution with Cal=200.\n</P><P>\n    Alternatively, we can minimize the item price:\n<PRE>\n        ?- bb_min(item(Food,Cal,Price), Price, bb_options{delta:0.05}).\n        Found a solution with cost 1.5\n        Found a solution with cost 0.99\n        Found no solution with cost -1.0Inf .. 0.94\n\n        Food = milk\n        Cal = 400\n        Price = 0.99\n        Yes (0.00s cpu)\n</PRE>\n    Because the price is non-integral, we had to adjust the step-width\n    of the optimization procedure using the delta-option.\n</P>\n<H3>Optimization with Constraints</H3>\n<P>\n    This library is designed to work together with arbitrary constraint\n    solvers, for instance library(ic).  The principle there is to wrap\n    the solver's nondeterministic search procedure into a bb_min/3 call.\n    This turns a program that finds all solutions into one that finds\n    the best solution.  For example:\n<PRE>\n        ?- [X,Y,Z] #:: 1..5,                   % constraints (model)\n           X+Z #>= Y,\n\n           C #= 3*X - 5*Y + 7*Z,               % objective function\n\n           bb_min(labeling([X,Y,Z]), C, _).    % nondet search + b&b\n\n        Found a solution with cost 5\n        Found a solution with cost 0\n        Found a solution with cost -2\n        Found a solution with cost -4\n        Found a solution with cost -6\n        Found no solution with cost -15.0 .. -7.0\n        X = 4\n        Y = 5\n        Z = 1\n        C = -6\n        Yes (0.00s cpu)\n</PRE>\n    The code shows the general template for such an optimization solver:\n    All constraints should be set up BEFORE the call to bb_min/3,\n    while the nondeterministic search procedure (here labeling/1)\n    must be invoked WITHIN bb_min/3.  The branch-and-bound procedure\n    only works if it envelops all nondeterminism.\n</P><P>\n    The cost variable (here C) must be defined in such a way that it is\n    instantiated (possibly by propagation) whenever the search procedure\n    succeeds with a solution.  Moreover, good, early bounds on the cost\n    variable are important for efficiency, as they help the branch-and-bound\n    procedure to prune the search.  Redundant constraints on the cost\n    variable can sometimes help.\n</P>\n\n<H3>Note on the treatment of bounded reals</H3>\n<P>\n    The library allows the cost to be instantiated to a number of type\n    breal.  This is useful e.g. when using lib(ic) to solve problems\n    with continuous variables.  When the variable domains have been\n    narrowed sufficiently, the problem variables (in particular the\n    cost variable) should be instantiated to a bounded real, e.g.\n    using the following idiom:\n    <PRE>\n\t    X is breal_from_bounds(get_min(X),get_max(X))\n    </PRE>\n    Bounded reals contain some uncertainty about their true value. If\n    this uncertainty is too large, the branch-and-bound procedure may\n    not be able to compare the quality of two solutions. In this case,\n    a warning is issued and the search terminated prematurely.  The\n    problem can be solved by increasing the delta-parameter, or by\n    locating the cost value more precisely.\n</P>")).
:- comment(bb_cost / 2, [summary : "Low-level primitive for building branch-and-bound-style search procedures", template : "bb_cost(++Handle, -Cost)", see_also : [bb_probe / 7]]).
:- comment(bb_finish / 1, [summary : "Low-level primitive for building branch-and-bound-style search procedures", template : "bb_finish(++Handle)", see_also : [bb_probe / 7]]).
:- comment(bb_init / 2, [summary : "Low-level primitive for building branch-and-bound-style search procedures", template : "bb_init(++ExtremeCost, -Handle)", see_also : [bb_probe / 7]]).
:- comment(bb_min / 3, [summary : "Find one or all minimal solutions using the branch-and-bound method", see_also : [bb_min / 6], desc : html("\tA solution of the goal <EM>Goal</EM> is found that minimizes\n\tthe value of <EM>Cost</EM>.  <EM>Cost</EM> should be a\n\tvariable that is affected, and eventually instantiated, by\n\t<EM>Goal</EM>.  Usually, <EM>Goal</EM> is the search procedure\n\tof a constraint problem and <EM>Cost</EM> is the variable\n\trepresenting the cost.  The solution is found using the branch\n\tand bound method:  as soon as a solution is found, it gets\n\tremembered and the search is continued or restarted with an\n\tadditional constraint on the <EM>Cost</EM> variable which\n\trequires the next solution to be better than the previous one. \n\tIterating this process finally yields an optimal solution.\n</P><P>\n\tThe possible options are\n\t<DL>\n\t<DT><STRONG>strategy:</STRONG></DT><DD>\n\t    <DL>\n\t    <DT>continue (default)</DT>\n\t    \t<DD>after finding a solution, continue search with the newly\n\t\tfound bound imposed on Cost</DD>\n\t    <DT>restart</DT>\n\t    \t<DD>after finding a solution, restart the whole search with\n\t\tthe newly found bound imposed on Cost</DD>\n\t    <DT>step</DT>\n\t    \t<DD>a synonym for 'restart'</DD>\n\t    <DT>dichotomic</DT>\n\t    \t<DD>after finding a solution, split the remaining cost range\n\t\tand restart search to find a solution in the lower sub-range.\n\t\tIf that fails, assume the upper sub-range as the remaining\n\t\tcost range and split again.</DD>\n\t    </DL>\n\t    The new bound (or the split point, respectively), is computed\n\t    from the current best solution, taking into account the\n\t    parameters delta and factor.\n\t    </DD>\n\t<DT><STRONG>from:</STRONG></DT>\n\t    <DD>number - an initial lower bound for the cost (default -1.0Inf).\n\t    Only useful if Cost is not a domain variable.</DD>\n\n\t<DT><STRONG>to:</STRONG></DT>\n\t    <DD>number - an initial upper bound for the cost (default +1.0Inf).\n\t    Only useful if Cost is not a domain variable.</DD>\n\n\t<DT><STRONG>delta:</STRONG></DT>\t\n\t    <DD>number - minimal absolute improvement required for each step\n\t    (applies to all strategies). The default value of 1.0 is\n\t    appropriate for integral costs.  Any solution that improves on\n\t    the best solution by less than this value will be missed.</DD>\n\n\t<DT><STRONG>factor:</STRONG></DT>\n\t    <DD>number - minimal improvement ratio (with respect to the lower\n\t    cost bound) for strategies 'continue' and 'restart' (default 1.0),\n\t    or split factor for strategy 'dichotomic' (default 0.5)</DD>\n\n\t<DT><STRONG>solutions:</STRONG></DT><DD>\n\t    <DL>\n\t    <DT>one (default)</DT><DD>\n\t\tCompute one (of possibly multiple) optimal solutions.</DD>\n\t    <DT>all</DT><DD>\n\t\tNondeterministically compute all optimal solutions.\n\t\tThis has a performance penalty, as the search is restarted\n\t\tone more time after the optimum has been determined.</DD>\n\t    </DL>\n\t    Note the dependence on the delta-parameter: the costs of these\n\t    solutions may deviate by less than delta from the true optimum.</DD>\n\n\t<DT><STRONG>timeout:</STRONG></DT>\n\t    <DD>number - maximum seconds of cpu time to spend (default: no limit)</DD>\n\n\t<DT><STRONG>report_success:</STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked whenever\n\t    the branch-and-bound process finds a better solution.  GoalPrefix\n\t    is a callable term (atom or compound) and N is an integer between\n\t    0 and 3.  The invoked goal is constructed by adding N optional\n\t    arguments to GoalPrefix: Cost, Handle and Module.  Cost is\n\t    a float number representing the cost of the solution found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.  \n\t    To disable any reporting, choose report_success:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\n\t<DT><STRONG>report_failure:</STRONG></STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked whenever\n\t    the branch-and-bound process cannot find a solution in a cost\n\t    range.  GoalPrefix is a callable term (atom or compound) and\n\t    N is an integer between 0 and 3.  The invoked goal is\n\t    constructed by adding N optional arguments to GoalPrefix:\n\t    Cost, Handle and Module.   Cost is a From..To structure\n\t    representing the range of cost in which no solution could be found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    To disable any reporting, choose report_failure:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\n\t<DT><STRONG>report_timeout:</STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked when the\n\t    branch-and-bound process times out.  GoalPrefix is a callable\n\t    term (atom or compound) and N is an integer between 0 and 3.\n\t    The invoked goal is constructed by adding N optional arguments\n\t    to GoalPrefix: Cost, Handle and Module.  Cost is a float number\n\t    representing the cost of the best solution found, Handle\n\t    is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    To disable any reporting, choose report_timeout:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\t</DL>\n\tThe default options can be selected by passing a free variable as\n\tthe Options-argument. To specify other options, pass a bb_options-\n\tstructure in struct-syntax, e.g.\n\t<PRE>\n\t    bb_min(..., ..., bb_options{strategy:dichotomic, timeout:60})\n\t</PRE>\n</P><P>\n\tIn order to maximize instead of minimizing, introduce a negated\n\tcost variable in your model and minimize that instead, e.g.\n\t<PRE>\n\t    % maximize Profit\n\t    Cost #= -Profit,\n\t    bb_min(search(...), Cost, bb_options{}),\n\t</PRE>\n</P>"), args : ["Goal" : "The (nondeterministic) search goal", "Cost" : "A (usually numeric domain) variable representing the cost", "Options" : "A bb_options structure or variable"], fail_if : "Goal has no solutions", amode : (bb_min(+, ?, +) is nondet), eg : "\n% simple minimization with default options\n    ?- bb_min(member(X,[9,6,8,4,7,2,4,7]), X, Options).\n    Found a solution with cost 9\n    Found a solution with cost 6\n    Found a solution with cost 4\n    Found a solution with cost 2\n    Found no solution with cost -1.0Inf .. 1\n    X = 2\n    Options = bb_options(continue, -1.0Inf, 1.0Inf, 1, 1, 0, 0, _, _)\n    yes.\n\n% coarser granularity: faster, but missing the optimum\n    ?- bb_min(member(X,[9,6,8,4,7,2,4,7]), X, bb_options{delta:4}).\n    Found a solution with cost 9\n    Found a solution with cost 4\n    Found no solution with cost -1.0Inf .. 0\n    X = 4\n    yes.\n\n% alternative strategy based on bisecting the cost space\n    ?- bb_min(member(X,[99,60,80,40,70,30,70]), X,\n\t    bb_options{strategy:dichotomic, from:0}).\n    Found a solution with cost 99\n    Found a solution with cost 40\n    Found no solution with cost 0.0 .. 20.0\n    Found a solution with cost 30\n    Found no solution with cost 20.0 .. 25.0\n    Found no solution with cost 25.0 .. 27.5\n    Found no solution with cost 27.5 .. 28.75\n    Found no solution with cost 28.75 .. 29.0\n    X = 30\n    yes.\n\n% examples with library(ic) constraints\n    ?- [X,Y,Z] :: 1..5,                    % constraints (model)\n       X+Z #>=Y,\n       C #= 3*X - 5*Y + 7*Z,               % objective function\n       bb_min(labeling([X,Y,Z]), C, _).    % nondet search + b&b\n\n    Found a solution with cost 5\n    Found a solution with cost 0\n    Found a solution with cost -2\n    Found a solution with cost -4\n    Found a solution with cost -6\n    Found no solution with cost -15.0 .. -7.0\n    X = 4\n    Y = 5\n    Z = 1\n    C = -6\n    Yes (0.00s cpu)\n\n\n    ?- [X,Y,Z] :: 1..5,\n       X+Z #>=Y,\n       C #= 3*X - 5*Y + 7*Z,\n       bb_min(search([X,Y,Z],0,input_order,indomain_middle,complete,[]), C, _).\n\n    Found a solution with cost 15\n    Found a solution with cost 8\n    Found a solution with cost 1\n    Found a solution with cost -4\n    Found a solution with cost -6\n    Found no solution with cost -15.0 .. -7.0\n    X = 4\n    Y = 5\n    Z = 1\n    C = -6\n    Yes (0.00s cpu)\n\n\n"]).
:- comment(bb_min / 6, [summary : "Find a minimal solution using the branch-and-bound method", see_also : [bb_min / 3], desc : html("\tA solution of the goal <EM>Goal</EM> is found that minimizes\n\tthe value of <EM>Cost</EM>.  <EM>Cost</EM> should be a\n\tvariable that is affected, and eventually instantiated, by\n\t<EM>Goal</EM>.  Usually, <EM>Goal</EM> is the search procedure\n\tof a constraint problem and <EM>Cost</EM> is the variable\n\trepresenting the cost.  The solution is found using the branch\n\tand bound method:  as soon as a solution is found, it gets\n\tremembered and the search is continued or restarted with an\n\tadditional constraint on the <EM>Cost</EM> variable which\n\trequires the next solution to be better than the previous one. \n\tIterating this process yields an optimal solution in the end.\n\t<P>\n\tThe possible options are\n\t<DL>\n\t<DT><STRONG>strategy:</STRONG></DT><DD>\n\t    <DL>\n\t    <DT>continue (default)</DT>\n\t    \t<DD>after finding a solution, continue search with the newly\n\t\tfound bound imposed on Cost</DD>\n\t    <DT>restart</DT>\n\t    \t<DD>after finding a solution, restart the whole search with\n\t\tthe newly found bound imposed on Cost</DD>\n\t    <DT>step</DT>\n\t    \t<DD>a synonym for 'restart'</DD>\n\t    <DT>dichotomic</DT>\n\t    \t<DD>after finding a solution, split the remaining cost range\n\t\tand restart search to find a solution in the lower sub-range.\n\t\tIf that fails, assume the upper sub-range as the remaining\n\t\tcost range and split again.</DD>\n\t    </DL>\n\t    The new bound (or the split point, respectively), are computed\n\t    from the current best solution, taking into account the\n\t    parameters delta and factor.\n\t    </DD>\n\t<DT><STRONG>from:</STRONG></DT>\n\t    <DD>number - an initial lower bound for the cost (default -1.0Inf)</DD>\n\n\t<DT><STRONG>to:</STRONG></DT>\n\t    <DD>number - an initial upper bound for the cost (default +1.0Inf)</DD>\n\n\t<DT><STRONG>delta:</STRONG></DT>\t\n\t    <DD>number - minimal absolute improvement required for each step\n\t    (default 1.0), applies to all strategies</DD>\n\n\t<DT><STRONG>factor:</STRONG></DT>\n\t    <DD>number - minimal improvement ratio (with respect to the lower\n\t    cost bound) for strategies 'continue' and 'restart' (default 1.0),\n\t    or split factor for strategy 'dichotomic' (default 0.5)</DD>\n\n\t<DT><STRONG>timeout:</STRONG></DT>\n\t    <DD>number - maximum seconds of cpu time to spend (default: no limit)</DD>\n\n\t<DT><STRONG>report_success:</STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked whenever\n\t    the branch-and-bound process finds a better solution.  GoalPrefix\n\t    is a callable term (atom or compound) and N is an integer between\n\t    0 and 3.  The invoked goal is constructed by adding N optional\n\t    arguments to GoalPrefix: Cost, Handle and Module.  Cost is\n\t    a float number representing the cost of the solution found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.  \n\t    To disable any reporting, choose report_success:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\n\t<DT><STRONG>report_failure:</STRONG></STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked whenever\n\t    the branch-and-bound process cannot find a solution in a cost\n\t    range.  GoalPrefix is a callable term (atom or compound) and\n\t    N is an integer between 0 and 3.  The invoked goal is\n\t    constructed by adding N optional arguments to GoalPrefix:\n\t    Cost, Handle and Module.   Cost is a From..To structure\n\t    representing the range of cost in which no solution could be found,\n\t    Handle is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    To disable any reporting, choose report_failure:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\n\t<DT><STRONG>report_timeout:</STRONG></DT>\n\t    <DD>GoalPrefix/N - this specifies a goal to be invoked when the\n\t    branch-and-bound process times out.  GoalPrefix is a callable\n\t    term (atom or compound) and N is an integer between 0 and 3.\n\t    The invoked goal is constructed by adding N optional arguments\n\t    to GoalPrefix: Cost, Handle and Module.  Cost is a float number\n\t    representing the cost of the best solution found, Handle\n\t    is a handle as accepted by bb_cost/2 or bb_solution/2,\n\t    and Module is the context module of the minimisation.\n\t    To disable any reporting, choose report_timeout:true/0.\n\t    The default handler prints a message to log_output.</DD>\n\t</DL>\n\tThe default options can be selected by passing a free variable as\n\tthe Options-argument. To specify other options, pass a bb_options-\n\tstructure in struct-syntax, e.g.\n\t<PRE>\n\tbb_options{strategy:dichotomic, timeout:60}\n\t</PRE>\n\tIn order to maximize instead of minimizing, introduce a negated\n\tcost variable in your model and minimize that instead.\n\t<P>\n\tUnlike bb_min/3, bb_min/6 does <STRONG>not</STRONG> affect Goal or Cost after\n\tthe optimum has been found. Instead, the optimum cost value is returned\n\tin Optimum, and the Solution argument gets unified with an instance of\n\tTemplate where the variables have the values that correspond to the\n\toptimal solution. Note that bb_min/3 is actually based on bb_min/6\n\tand can (for the one-solution case) be defined as:\n\t<PRE>\n\tbb_min(Goal, Cost, Options) :-\n\t    bb_min(Goal, Cost, Goal, Goal, Cost, Options).\n\t</PRE>\n\t"), args : ["Goal" : "The (nondeterministic) search goal", "Cost" : "A (usually numeric domain) variable representing the cost", "Template" : "A term containing all or some problem variables", "Solution" : "A term which will be unified with the optimized Template", "Optimum" : "A variable which will be set to the optimum value of Cost", "Options" : "A bb_options structure or variable"], fail_if : "Goal has no solutions", amode : (bb_min(+, ?, ?, ?, ?, ?) is semidet)]).
:- comment(bb_min_cost / 4, [summary : "Find the minimal cost using the branch-and-bound method", args : ["Goal" : "The (nondeterministic) search goal", "Cost" : "A (usually numeric domain) variable representing the cost", "Optimum" : "A variable which will be set to the optimum value of Cost", "Options" : "A bb_options structure or variable"], see_also : [bb_min / 3, bb_min / 6], desc : html("<P>    Determines the minimum possible value that the variable Cost can\n    attain in any solution of Goal.  This value is returned as Optimum.\n    Neither Cost nor any variable in Goal is instantiated.  The predicate\n    is useful when one is interested in sub-optimal solutions, see example.\n</P><P>\n    This predicate can be defined as\n<PRE>\n\tbb_min_cost(Goal, Cost, Optimum, Options) :-\n\t\tbb_min(Goal, Cost, [], _, Optimum, Options).\n</PRE>\n    Options are interpreted in the same way as for bb_min/6\n    (the solutions-parameter is ignored).\n</P>"), fail_if : "Goal has no solutions", amode : (bb_min_cost(+, ?, -, +) is semidet), eg : "\n    % A predicate to enumerate solutions in increasing cost order\n    :- lib(ic).\n    :- lib(branch_and_bound).\n\n    ic_increasing_cost(Goal, Cost) :-\n    \tbb_min_cost(Goal, Cost, Opt,\n\t\t    bb_options{report_success:true/0,report_failure:true/0}),\n\t(\n\t    Cost = Opt,\n\t    call(Goal)\n\t;\n\t    Cost #> Opt,\n\t    ic_increasing_cost(Goal, Cost)\n\t).\n\n    % sample run:\n    ?- ic_increasing_cost(member(C-X,[9-a,4-b,2-c,4-d]), C).\n    C = 2\n    X = c\n    Yes (0.00s cpu, solution 1, maybe more) ? ;\n    C = 4\n    X = b\n    Yes (0.00s cpu, solution 2, maybe more) ? ;\n    C = 4\n    X = d\n    Yes (0.00s cpu, solution 3, maybe more) ? ;\n    C = 9\n    X = a\n    Yes (0.00s cpu, solution 4, maybe more) ? ;\n    No (0.00s cpu)\n    "]).
:- comment(bb_probe / 7, [summary : "Low-level primitive for building branch-and-bound-style search procedures", template : "bb_probe(++From, ++To, +Goal, ?Template, ?Cost, ++Handle, ++Module)", desc : html("\n\tbb_probe tries to find a solution for Goal in the range From..To.\n\tIf there is a solution, its Template and Cost are stored in Handle,\n\tthe computation is undone, and bb_probe succeeds.\n\tIf there is no solution, Handle is not changed and bb_probe fails.\n\tThe primitive set_var_bounds/3 is used to impose cost bounds\n\tduring the search process in a generic way."), see_also : [bb_init / 2, bb_cost / 2, bb_solution / 2, bb_finish / 1, bb_min / 3, bb_min / 6, set_var_bounds / 3], eg : "% a simple branch-and-bound procedure\nmy_minimize(Goal, Cost, Solution, OptCost, Module) :-\n\tbb_init(1000000, Handle),\n\t(\n\t    bb_delta(0, 1000000, Goal, Cost, Handle, Module)\n\t;\n\t    bb_solution(Handle, Solution),\n\t    bb_cost(Handle, OptCost)\n\t),\n\tbb_finish(Handle).\n\nbb_delta(From, To, Goal, Cost, Handle, Module) :-\n\tbb_probe(From, To, Goal, Goal, Cost, Handle, Module),\n\tNewTo is bb_cost(Handle) - 1,\n\tbb_delta(From, NewTo, Goal, Cost, Handle, Module).\n    "]).
:- comment(bb_solution / 2, [summary : "Low-level primitive for building branch-and-bound-style search procedures", template : "bb_solution(++Handle, -Solution)", see_also : [bb_probe / 7]]).
:- comment(minimize / 2, [summary : "Find a minimal solution using the branch-and-bound method", desc : html("This is a shorthand for\n    \t<PRE>\n\tbb_min(+Goal, ?Cost, _DefaultOptions)\n\t</PRE>\n\tSee bb_min/3 for details."), template : "minimize(+Goal, ?Cost)", see_also : [bb_min / 3]]).
