:- module(ic_mdd).
:- export mddc / 2.
:- export table / 2.
:- comment(summary, "Extensional constraints over IC variables").
:- comment(categories, ["Constraints"]).
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Joachim Schimpf, Coninfer Ltd").
:- comment(date, "$Date: 2017/09/28 22:43:43 $").
:- comment(mddc / 2, [amode : mddc(?, ++), args : ["Tuple" : "A collection of finite domain variables", "MDD" : "A graph (multi-valued decision diagram)"], summary : "The variables in Tuple only take values allowed by the given multi-valued decision diagram MDD", kind : [constraint : [root : [ic, fd]]], desc : html("<P>    This constraint is defined extensionally via a multi-valued decision\n    diagram (MDD), which in turn is represented as a graph (in the format\n    of library(graph_algorithms)).\n    <P>\n    The MDD is a compact encoding of all valid tuples X1,..,XN, and must\n    be constructed as follows:\n    <UL> \n    <LI>The graph nodes are numbered 1..M, where M is the number of nodes.\n    <LI>Node M is the root node (the unique source node).\n    <LI>Node 1 is the 'true' node (the unique sink node).\n    <LI>Each node is labelled with a variable index between 1 and N\n\t(apart from the true-node, which is labelled with 0).  All\n\tnodes on the same level must have the same index label.\n    <LI>Edges lead from the root node towards the true-node.  On each path\n    \tfrom root to true, each variable index is encountered exactly once,\n\tand in the same order on every path.\n    <LI>If a path traverses a node annotated with i, and the outgoing edge is\n    \tannotated with value j, then X[i]=j in the tuple defined by this path.\n    <LI>Each path from root to true defines one valid tuple.\n    </UL> \n    <P>\n    Declaratively, the variables in Tuple are constrained to take only\n    values allowed by the decision diagram, i.e. corresponding to paths \n    from the root to the true-node.  Operationally, the constraint\n    maintains arc-consistency, i.e. it keeps removing all domain values\n    that can no longer be part of a solution.\n    <P>\n    Tuple can be a collection expression as understood by eval_to_list/2;\n    if uninstantiated, it will be bound to a list.\n    <P>\n    The implementation uses the algorithm from Cheng&Yap: Maintaining\n    Generalized Arc Consistency on Ad Hoc r-Ary Constraints, CP 2008.\n"), see_also : [library(graph_algorithms), graph_algorithms : make_graph / 3, table / 2], eg : "\n    % ------------------------------------------------------------\n    % Example 1\n    % ------------------------------------------------------------\n\n    % To allow the tuples [1,1,1], [1,2,3] and [3,3,3] we use the\n    % following decision diagram (where (1)-(6) are node numbers):\n    %\n    %       (6)        X[1]\n    %       / \\\n    %      1   3\n    %     /     \\\n    %    (4)   (5)     X[2]\n    %    |  \\    |\n    %    1   2   3\n    %    |    \\  |\n    %    (2)   (3)     X[3]\n    %     \\     /\n    %      1   3\n    %       \\ /\n    %       (1)        true\n\n    :- lib(ic).\t\t% or lib(fd)\n    :- lib(ic_mdd).\t% or lib(fd_mdd)\n    :- lib(graph_algorithms).\n\n    % Make a graph describing the MDD\n\n    sample_mdd(MDD) :-\n        make_graph(6, [                  % Edges: e(FromNode,ToNode,EdgeValue)\n                e(6,4,1), e(6,5,3),\n                e(4,2,1), e(4,3,2), e(5,3,3),\n                e(2,1,1), e(3,1,3)\n            ], MDD),\n        Nodez = [](0,3,3,2,2,1),         % Variable index for node (1) to (6)\n        graph_set_nodenames(MDD, Nodez).\n\n\n    % Sample run:\n\n    ?- sample_mdd(MDD), mddc(Xs, MDD), labeling(Xs).\n    Xs = [1, 1, 1]\n    MDD = graph(...)\n    Yes (0.00s cpu, solution 1, maybe more)\n\n    Xs = [1, 2, 3]\n    MDD = graph(...)\n    Yes (0.00s cpu, solution 2, maybe more)\n\n    Xs = [3, 3, 3]\n    MDD = graph(...)\n    Yes (0.00s cpu, solution 3)\n\n\n    % ------------------------------------------------------------\n    % Example 2\n    % ------------------------------------------------------------\n\n    :- lib(ic).\t\t% or lib(fd)\n    :- lib(ic_mdd).\t% or lib(fd_mdd)\n    :- lib(mdd_support).\n\n    crossword :-\n        dim(Grid, [4,4]),\n        words4(Words),\n\n        % constrain rows and columns to be words\n        sort(Words, WordsOrdered),\n        ordered_tuples_to_mdd(WordsOrdered, MDD),\n\n        ( for(I,1,4), param(Grid,MDD) do\n            mddc(Grid[I,*], MDD),\n            mddc(Grid[*,I], MDD)\n        ),\n\n        % find solution(s)\n        labeling(Grid),\n\n        % print result\n        ( foreachelem(Char,Grid,[_,J]) do\n            ( J==1 -> nl ; put(0' ) ), put(Char)\n        ).\n\n    % List of allowed words\n    % Note: `aloe` is the same as the list [0'a, 0'l, 0'o, 0'e], which\n    % is the same as the list of character codes [97, 108, 111, 101]\n    words4([`aloe`, `back`, `bash`, `soil`, `help`, `kelp`, `luck`]).\n\n\n    % Sample run:\n    ?- crossword.\n\n    b a s h\n    a l o e\n    s o i l\n    h e l p\n"]).
:- comment(table / 2, [amode : table(+, ++), args : ["Tuples" : "A collection of tuples of finite domain variables - these will be constrained", "Table" : "A collection of tuples of integers"], summary : "Constrain all tuples to take values from the table rows", kind : [constraint : [root : [ic, fd]]], see_also : [mddc / 2, eval_to_list / 2], desc : html("<P>    This constraint is defined extensionally, i.e. by an explicit table\n    of value tuples that are valid solutions.\n    <P>\n    Declaratively, all tuples in Tuples are constrained to take only\n    values from Table.  Operationally, for each tuple in Tuples, this\n    constraint maintains arc-consistency, i.e. removes all domain\n    values that can no longer be part of a solution.  Posting the\n    constraint with multiple tuples in Tuples is equivalent\n    (declaratively and consistency-wise) to posting an individual\n    table-constraint for each tuple in Tuples.\n    <P>\n    The tuples in both Tuples and Table can be lists, arrays or any\n    collection expression understood by eval_to_list/2.\n    <P>\n    Compatibility: This constraint is known as in_relation in the global\n    constraint catalog, as table/2 in SICStus Prolog, and extensional()\n    in Gecode.\n"), eg : "\n    :- lib(ic).\t\t% or lib(fd)\n    :- lib(ic_mdd).\t% or lib(fd_mdd)\n\n    crossword :-\n        dim(Grid, [4,4]),\n        words4(Words),\n\n        % constrain rows and columns to be words\n        ( for(I,1,4), fromto(Slots,Slots1,Slots2,[]), param(Grid) do\n            Slots1 = [Grid[I,*], Grid[*,I] |Slots2]\n        ),\n        table(Slots, Words),\n\n        % find solution(s)\n        labeling(Grid),\n\n        % print result\n        ( foreachelem(Char,Grid,[_,J]) do\n            ( J==1 -> nl ; put(0' ) ), put(Char)\n        ).\n\n    % List of allowed words\n    % Note: `aloe` is the same as the list [0'a, 0'l, 0'o, 0'e], which\n    % is the same as the list of character codes [97, 108, 111, 101]\n    words4([`aloe`, `back`, `bash`, `soil`, `help`, `kelp`, `luck`]).\n\n\n    % Sample run:\n    ?- crossword.\n\n    b a s h\n    a l o e\n    s o i l\n    h e l p\n"]).
