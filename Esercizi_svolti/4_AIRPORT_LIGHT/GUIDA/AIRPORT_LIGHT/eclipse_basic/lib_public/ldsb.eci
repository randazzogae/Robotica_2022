:- module(ldsb).
:- export ldsb_initialise / 2.
:- export ldsb_try / 3.
:- export ldsb_try_set / 3.
:- export ldsb_indomain / 1.
:- export ldsb_indomain_set / 1.
:- export run_tests / 0.
:- comment(categories, ["Constraints", "Techniques"]).
:- comment(summary, "Lightweight dynamic symmetry breaking for finite domains.").
:- comment(author, "Chris Mears").
:- comment(desc, html("</p>\n\n   The LDSB (lightweight dynamic symmetry breaking) library adds\n   symmetry breaking to search.  Its aim is to provide easy-to-use\n   symmetry breaking to their finite domain constraint models.  The\n   method is described in \"<i>Lightweight Dynamic Symmetry\n   Breaking</i>. C. Mears, M. Garcia de la Banda, B. Demoen,\n   M. Wallace.  <i>SymCon'08</i>\".\n                     \n   <p/>\n\n   To use LDSB, first call ldsb_initialise/2 with the search variables\n   for which you want to use symmetry breaking and a specification of\n   the symmetries.  LDSB supports binary search branching of the form\n   <tt>Var = Val</tt> and <tt>Var /= Val</tt>, or <tt>Val in Var</tt>\n   and <tt>Val notin Var</tt> for sets.  Use ldsb_indomain/1 and\n   ldsb_indomain_set/1 to instantiate variables during search, or\n   ldsb_try/3 and ldsb_try_set/3 for a custom branching.")).
:- comment(status, "evolving").
:- comment(ldsb_indomain / 1, [amode : ldsb_indomain(?), args : ["X" : "Variable or integer"], resat : yes, see_also : [ldsb_indomain_set / 1, ldsb_initialise / 2], summary : "Instantiates an LDSB integer variable to an\n             element of its domain.", desc : html("<p/> Simple predicate for instantiating an\n             integer LDSB variable to an element of its domain. It\n             starts with the smallest element, and upon backtracking\n             tries successive elements until the entire domain has\n             been explored, at which point the predicate fails.\n\n             <p/>If X is already a ground integer, then this predicate\n             simply succeeds exactly once without leaving a\n             choicepoint.\n\n             <p/>This predicate can be used with the search/6\n             predicate (see example)."), eg : "\ngo :-\n        dim(Xs, [3]),\n        Xs #:: 1..5,\n        collection_to_list(Xs, L), sum(L) #= 10,\n        ldsb_initialise(Xs, [variables_interchange]),\n        ( search(Xs, 0, input_order, ldsb_indomain, complete, []),\n          writeln(Xs),\n          fail\n        ; true ).\n"]).
:- comment(ldsb_indomain_set / 1, [amode : ldsb_indomain_set(?), args : ["X" : "Set variable or set"], resat : yes, see_also : [ldsb_indomain / 1, ldsb_initialise / 2], summary : "Instantiates an LDSB set variable to an element\n             of its domain.", desc : html("<p/> Simple predicate for instantiating a set\n             LDSB variable to an element of its domain.  If a set\n             value is considered a binary number, where 1 is inclusion\n             and 0 is exclusion, the value ordering is descending.\n             For example:\n\n             <pre>\ngo :-\n    intset(S, 1, 3),\n    Xs = [](S),\n    ldsb_initialise(Xs, []),\n    ( ldsb_indomain_set(S), writeln(S), fail\n    ; true).\n             </pre>\n\n             would produce the following output:\n\n             <pre>\n[1, 2, 3]\n[1, 2]\n[1, 3]\n[1]\n[2, 3]\n[2]\n[3]\n[]\n             </pre>\n\n             <p/>If X is already a ground set, then this predicate\n             simply succeeds exactly once without leaving a\n             choicepoint.\n\n             <p/>This predicate can be used with the search/6\n             predicate (see example)."), eg : "\ngo :-\n        intsets(L, 3, 1, 10),\n        ( foreach(S, L) do #(S, 3) ),\n        ( fromto(L, [X|Xs], Xs, []) do\n          ( foreach(Y, Xs), param(X) do\n              #(X /\\ Y, 0) ) ),\n        Xs =.. [[]|L],\n        ldsb_initialise(Xs, [values_interchange]),\n        ( search(Xs, 0, input_order, ldsb_indomain_set, complete, []),\n          writeln(Xs),\n          fail\n        ; true ).\n"]).
:- comment(ldsb_initialise / 2, [amode : (ldsb_initialise(+, +) is det), args : ["Xs" : "Array of search variables", "Syms" : "List of symmetries"], summary : "Initialise LDSB search variables.", resat : no, see_also : [ldsb_try / 3, ldsb_indomain / 1, ldsb_indomain_set / 1], desc : html(" <p/> Initialise an array of search variables\nto use LDSB with the given symmetries.  A variables must be\ninitialised with ldsb_initialise before it can be used with ldsb_try\nor any predicate that relies on it such as ldsb_indomain.\n\n</p> Each element of Syms must be a symmetry specifier from the\nfollowing set:\n\n<ul>\n\n<li> variable_interchange(L).  This specifies that the variables in\nthe list L are interchangeable.\n\n<li> value_interchange(L).  This specifies that the values in the list\nL are interchangeable.\n\n<li> parallel_variable_interchange(Ls).  This specifies that the lists\nof variables in the list L are interchangeable.  Each list in Ls must\nhave the same length.  For example,\nparallel_variable_interchange([A,B,C],[D,E,F],[G,H,I]) says that the\nsequence A-B-C can be interchanged with the sequence D-E-F and the\nsequence G-H-I.\n\n<li> parallel_value_interchange(Ls).  This specifies that the lists of\nvalues in the list L are interchangeable.  It is the same as\nparallel_variable_interchange, but for values.\n\n<li> variables_interchange.  This specifies that all variables in Xs\nare interchangeable.\n\n<li> values_interchange.  This specifies that all values in the\ndomains of the variables in Xs are interchangeable.  Note that for\nthis specifier it is assumed that all variables in Xs have the same\ndomain.\n\n<li> rows_interchange.  This specifies that the rows of variables in\nXs are interchangeable.  Assumes that Xs is a 2D matrix of variables.\n\n<li> columns_interchange.  This specifies that the columns of\nvariables in Xs are interchangeable.  Assumes that Xs is a 2D matrix\nof variables.\n\n<li> diagonal_reflection.  This specifies that the variables of Xs can\nbe reflected around the main diagonal.  Assumes that Xs is a 2D matrix\nof variables.\n\n<li> row_reflection.  This specifies that the rows of Xs can be\nreflected around their centre.  Assumes that Xs is a 2D matrix of\nvariables.\n\n<li> column_reflection.  This specifies that the columns of Xs can be\nreflected around their centre.  Assumes that Xs is a 2D matrix of\nvariables.\n\n<li> value_reflection(L, U).  This specifies that the values in the\nsequence L..U can be reflected; i.e. value L+i maps to U-i.\n\n<li> value_reflection.  This is the same as value_reflection(L,U),\nwhere L and U are taken from the minimum and maximum values in the\ndomain of the first variable in Xs.\n\n</ul> "), eg : "\n% A vector of interchangeable variables.\ndim(Xs, [N]),\n[...]\nldsb_initialise(Xs, [variables_interchange])\n\n% Vector of piecewise interchangeable variables.\nXs = [](A,B,C,D,E,F),\n[...]\n% A,B,C are interchangeable; D,E,F are interchangeable.\nldsb_initialise(Xs, [variable_interchange([A,B,C]),\n                     variable_interchange([D,E,F])])\n\n% Variables with interchangeable values.\ndim(Xs, [N]),\nXs #:: 1..M,\nldsb_initialise(Xs, [values_interchange])\n\n% N-queens, with one boolean variable per square.\ndim(A, [N,N]),\nA #:: 0..1,\n[...]\nldsb_initialise(A, [row_reflection, column_reflection, diagonal_reflection])\n\n% N-queens with one integer variable per queen.\n% Note that only half of the symmetries are represented.\ndim(Xs, [1,N]),    % make Xs a 1xN matrix.\nXs #:: 1..N,\n[...]\nldsb_initialise(Xs, [column_reflection, value_reflection])\n\n% Latin square of order N.\ndim(Xs, [N,N]),\nXs #:: 1..N,\n[...]\nldsb_initialise(Xs, [rows_interchange, columns_interchange, values_interchange, diagonal_reflection])\n\n% Social Golfers problem with one set variable per group.\ndim(Xs, [W,G]),\n[...]\n% Within each week, the groups are interchangeable.\n( for(I, 1, W), foreach(Subsym, Subsyms), param(Xs,G) do\n    subscript(Xs, [I, 1..G], Submatrix),\n    variables_interchange(Submatrix, Subsym) ),\n% rows_interchange: weeks are interchangeable\n% values_interchange: golfers are interchangeable\nldsb_initialise(Xs, [rows_interchange, values_interchange | Subsyms])\n"]).
:- comment(ldsb_try / 3, [amode : ldsb_try(+, ++, ?), args : ["X" : "Variable to try", "Value" : "Value to try", "Success" : "Whether the assignment succeeded or not"], resat : yes, see_also : [ldsb_indomain / 1, ldsb_initialise / 2, ldsb_try_set / 3], summary : "Try assigning a value to an LDSB variable.", desc : html("<p/> Tries to assign Value to X.  Upon\n             backtracking, excludes Value from the domain of X.  The\n             value of Success tells whether the assignment succeeded;\n             Success is 1 if X #= Value and 0 if X #\\= Value."), eg : "\nldsb_indomain(X) :- nonvar(X), !.\nldsb_indomain(X) :-\n        ic:is_solver_var(X), !,\n        get_min(X,V),\n        ldsb_try(X, V, _),\n        ldsb_indomain(X)."]).
:- comment(ldsb_try_set / 3, [amode : ldsb_try_set(+, ++, ?), args : ["X" : "Variable to try", "Value" : "Value to try", "Success" : "Whether the inclusion succeeded or not"], resat : yes, see_also : [ldsb_indomain_set / 1, ldsb_initialise / 2, ldsb_try / 3], summary : "Try including a value in an LDSB set variable.", desc : html("<p/> Tries to include Value in X.  Upon\n             backtracking, excludes Value from X.  The value of\n             Success tells whether the inclusion succeeded; Success is\n             1 if (Value in X) and 0 if Value has been excluded.\n\n             <p/> Note that due to the interaction between set\n             variable searching and value symmetries, using this\n             predicate in discouraged.  Use ldsb_indomain_set/1\n             instead.")]).
:- comment(run_tests / 0, hidden).
