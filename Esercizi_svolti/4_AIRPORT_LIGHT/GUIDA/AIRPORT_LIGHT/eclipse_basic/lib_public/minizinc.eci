:- module(minizinc).
:- reexport struct(_198729) from flatzinc.
:- export macro((of) / 2, tr_of / 2, []).
:- export mzn_run / 2.
:- export mzn_run / 3.
:- export mzn_run_string / 2.
:- export mzn_load_string / 5.
:- export mzn_load / 5.
:- export mzn2fzn / 4.
:- export mzn_run / 0.
:- comment(date, "$Date: 2016/07/24 19:34:45 $").
:- comment(categories, ["Interfacing", "Constraints"]).
:- comment(summary, "Utilities for using MiniZinc with ECLiPSe").
:- comment(author, "Joachim Schimpf, supported by Cisco Systems and NICTA Victoria").
:- comment(copyright, "Cisco Systems Inc, licensed under CMPL").
:- comment(see_also, [flatzinc : struct(zn_options), library(flatzinc), library(fzn_ic), library(fzn_fd), library(fzn_eplex)]).
:- comment(status, prototype).
:- comment(desc, html("\n<H3>\nOverview\n</H3>\n<P>\nThis module allows to run MiniZinc models with ECLiPSe.\nMiniZinc models can be either read from a file or stream,\nor they can be embedded as strings into ECLiPSe code.\nThe implementation relies on an external MiniZinc-to-FlatZinc converter,\ne.g. mzn2fzn, and on the FlatZinc interpreter lib(flatzinc).\nMappings to different ECLiPSe solvers are possible via the solver\nmapping libraries fzn_ic, fzn_fd, fzn_eplex, etc.\n</P>\n\n<H3>\nRunning MiniZinc Models without using this Library\n</H3>\n<P>\nYou can run a MiniZinc model by first converting it to FlatZinc yourself,\nand then using the lib(flatzinc) library. This can be done either via\nan intermediate .fzn file, or by piping the resulting FlatZinc model\ninto the ECLiPSe-FlatZinc interpreter using e.g.\n<PRE>\n% mzn2fzn --output-to-stdout model.mzn | eclipse -e \"flatzinc:fzn_run(fzn_ic)\"\n</PRE>\nThis should work as long as the mzn2fzn command is in your PATH.\nNote that mzn2fzn is currently not included with ECLiPSe but comes\nwith the Melbourne MiniZinc distribution.  You must also make sure that\nthe correct specialised global constraint definitions are used,\nby including e.g. lib/fzn_ic in mzn2fzn's search path via its -I option.\nFor more details see lib(flatzinc).\n</P>\n\n<H3>\nRunning MiniZinc Models using this Library\n</H3>\n<P>\nThis library allows you to do everything from within ECLiPSe and let ECLiPSe\ninvoke the MiniZinc to FlatZinc translator (mzn2fzn) internally with the\ncorrect arguments.  The model can be contained in a file:\n<PRE>\n?- mzn_run(\"model.mzn\", fzn_ic).\n</PRE>\nor, if a data instance file is used\n<PRE>\n?- mzn_run(\"model.mzn\", \"instance.dzn\", fzn_ic).\n</PRE>\nSince MiniZinc models are typically small, they can also be embedded as\na string into ECLiPSe code. For example:\n<PRE>\n    queens8 :-\n\tmzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n</PRE>\nNote that, because of the rules for escaping characters within\nECLiPSe strings, the backslashes had to be doubled!\n</P>\n\n<H3>\nInstallation\n</H3>\n<P>\nThis version is intended to to work with Minizinc 1.6 or later!\n<P>\nIn order to be found by lib(minizinc), the Melbourne Minizinc-to-Flatzinc\nconverter mzn2fzn (and the corresponding output processor solns2out) must be\ninstalled in a directory called <CODE>minizinc-&lt;version&gt;</CODE> (or similar)\nin one of the following locations (where we write &lt;ECLIPSEDIR&gt; for\nthe ECLiPSe installation directory, and &lt;ECLIPSEARCH&gt; for\nthe name for the machine architecture, e.g. i386_nt for Windows, i386_linux\nfor Linux):\n<OL>\n<LI>Directory specified by <CODE>$ECLIPSEMZN</CODE> environment variable</LI>\n<LI>The user's home directory, as indicated by $HOME or $HOMEPATH</LI>\n<LI><CODE>&lt;location of lib(minizinc)&gt;/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;/lib_public/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;/lib/&lt;ECLIPSEARCH&gt;</CODE></LI>\n<LI><CODE>&lt;ECLIPSEDIR&gt;</CODE></LI>\n<LI>Parent of <CODE>&lt;ECLIPSEDIR&gt;</CODE> (e.g. \"C:/Program Files\" on Windows)</LI>\n<LI>Directory specified by <CODE>$PROGRAMFILES</CODE> environment variable</LI>\n</OL>\n<P>\nYou can also set the environment variable ECLIPSEMZN (on Windows alternatively\nthe registry entry HKLM/SOFTWARE/IC-Parc/Eclipse/<version>/ECLIPSEMZN)\nto the Minizinc installation directory (or to its parent).\n\n\n<H3>\nCombining a MiniZinc model with Search or I/O in ECLiPSe\n</H3>\n<P>\nThere are several reasons why one might want to embed a MiniZinc model\ninto an ECLiPSe program:\n<UL>\n<LI>Passing parameters from the ECLiPSe program to the MiniZinc model</LI>\n<LI>Getting the model solutions back into ECLiPSe</LI>\n<LI>Programming custom search in ECLiPSe</LI>\n<LI>Doing custom output beyond what the Zinc output annotations can do</LI>\n</UL>\n</P><P>\nTo pass a parameter into a MiniZinc model, a generic MiniZinc model must\nbe provided, together with a parameter map.\nThis map is an ECLiPSe list that corresponds to a MiniZinc (actually\nFlatZinc) instance file:\n<PRE>\nqueens(N) :-\n\tmzn_run_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    [n=N],\t% parameter map: ZincId=EclipseValue\n\t    fzn_ic).\n</PRE>\nAlternatively, the generic model can be kept separately in a MiniZinc file:\n<PRE>\nqueens(N) :-\n\tmzn_run(\"n_queens.mzn\", [n=N], fzn_ic).\n</PRE>\n<P>\nWith the above exmples, search and output are still completely specified\nin MiniZinc.\n</P><P>\nTo add your own search routine and/or output, use mzn_load_string/5 or\nmzn_load/5. This has the effect of only loading the MiniZinc model\n(i.e. setting up the constraints), but then returning to ECLiPSe without\nexecuting any MiniZinc solve or output primitives.  The rest of the work\ncan then be done in ECLiPSe:\n</P>\n<PRE>\nqueens(N, Q) :-\n\tmzn_load(\"n_queens.mzn\", fzn_ic, [n=N], [q=Q], FznState),\n\tlabeling(Q),\n\tfzn_output(FznState).\n</PRE>\nThe [q=Q] mapping gives access to the ECLiPSe array Q corresponding to\nthe MiniZinc array q. This is a normal ECLiPSe array of lib(ic) domain\nvariables, and can be used for doing search, or outputting the results.\nIn the example however, we have fallen back onto the FlatZinc output\nroutine to display the results after search has finished.\n</P><P>\nNote that even if you do your own search in ECLiPSe, your MiniZinc model\nmust contain a solve item to be syntactically correct (and to specify\nthe objective, if any).\n</P>\n\n<H3>\nOptions\n</H3>\nInstead of just the name of the solver mapping (<CODE>fzn_ic</CODE> in\nour examples), a <CODE>zn_options{}</CODE> structure can be given to\ncustomize the behaviour further, e.g.\n<PRE>\n\tmzn_run(File, zn_options{solver:fzn_eplex,var_names:on}.\n</PRE>\n<DL>\n<DT>solver (default: fzn_ic)</DT><DD>\n    Determines which ECLiPSe solvers are used.  The name is the\n    name of a library implementing the mapping, e.g. fzn_ic,\n    fzn_fd or fzn_eplex.\n</DD>\n<DT>solutions (default: 1)</DT><DD>\n    The maximum number of solutions computed. Only effective if using\n    builtin search and not optimizing. (0 or all = all solutions)\n</DD>\n<DT>setup_prio (default: 0)</DT><DD>\n    The priority under which the constraint setup will be executed\n    (see call_priority/2 and get_priority/1). Possible values are\n    the ECLiPSe priorities 1 to 12, or 0 (the default) which stands\n    for the current priority of the calling code.  A sensible value\n    for this option is 2, which means that the setup code is executed\n    under high priority (still allowing debug/visualisation goals).\n    The effect of such a setting is that no propagation occurs until\n    all constraints are fully set up, possibly leading to time savings.\n</DD>\n<DT>parser (default: fast)</DT><DD>\n    Whether to use a 'strict' or 'fast' parser for FlatZinc input.\n</DD>\n<DT>optimize (default: on)</DT><DD>\n    If 'off', pass --no-optimize to the Minizinc-Flatzinc translator.\n    This can improve performance on large models.\n</DD>\n<DT>timeout (default: 0)</DT><DD>\n    Time limit in seconds. (0 means no timeout),\n</DD>\n<DT>var_names (default: off)</DT><DD>\n    Use lib(var_name) to label ECLiPSe variables with their Zinc names.\n    This is useful for debugging.\n</DD>\n<DT>fzn_tmp (default: file)</DT><DD>\n    Use a 'pipe' or intermediate 'file' for FlatZinc.\n</DD>\n</DL>\n\n<H3>\nMapping between MiniZinc/FlatZinc Data and ECLiPSe Data\n</H3>\n<P>\nWhen using ECLiPSe with a Mini/FlatZinc model, one needs to be aware of\nthe mapping from MiniZinc to FlatZinc (e.g. flattening of arrays),\nand the representation of FlatZinc data in ECLiPSe.\n</P><P>\nNote that the ECLiPSe-side representation depends in part on the chosen\nsolver mapping. The following table shows the mapping used with fzn_ic\n(which employs the lib(ic) and lib(ic_sets) solver libraries):\n<PRE>\n\tFlatZinc Type/Syntax\t\tECLiPSe Type/Syntax\n\t-----------------------------------------------------------\n\tstring\t\t\t\tstring\n\te.g.\t\"abc\"\t\t\t\"abc\"\n\n\tbool (false/true)\t\tinteger (0/1)\n\te.g.\tfalse\t\t\t0\n\n\tint\t\t\t\tinteger\n\te.g.\t33\t\t\t33\n\n\tfloat\t\t\t\tfloat or breal\n\te.g.\t3.4\t\t\t3.399__3.401\n\n\tset of int\t\t\tordered list of integer\n\te.g.\t{1,5,4}\t\t\t[1,4,5]\n\t\t1..3\t\t\t[1,2,3]\n\n\tarray[1..N] of T\t\tstructure with functor []/N\n\te.g.\t[23,54,0]\t\t[](23,54,0)\n\n\tvar bool\t\t\tlib(ic) integer variable\n\n\tvar int\t\t\t\tlib(ic) integer variable\n\n\tvar float\t\t\tlib(ic) continuous variable\n\n\tvar set of int\t\t\tlib(ic_sets) set variable\n</PRE>\n</P>\n")).
:- comment(mzn2fzn / 4, [summary : "Convert a MiniZinc model into a FlatZinc model", amode : (mzn2fzn(+, +, ++, ?) is det), args : ["ModelFile" : "File name (extension defaults to .mzn)", "InstFileOrParMap" : "Instance file name (extension defaults to .dzn), or list of Id=Term correspondences", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "FznFile" : "Name of generated FlatZinc file (will be generated if variable)"], see_also : [mzn_run / 3, flatzinc : fzn_run / 2, struct(zn_options)], desc : html("<P>\n\tConverts a MiniZinc model (given a model file and an instance\n\tfile or parameter map) into a FlatZinc model, by invoking the\n\texternal mzn2fzn converter with the appropriate arguments.\n\tIf no output file name is specified (FznFile uninstantiated),\n\tthe name of the output file is the same as the input file, with\n\tthe extension changed to .fzn.  The options should specify the\n\tsolver that is intended to be used on the FlatZinc model (so that\n\tthe correct version of globals.mzn is used), and the fzn_tmp\n\toption should be set to 'file' (the default).\n    </P><P>\n\tA file with output instructions is also generated.  It has the same\n\tbase name as FznFile (if given) or ModelFile, with the extension\n\tchanged to .ozn.\n    </P>"), eg : "\n    ?- mzn2fzn(mymodel, [], zn_options{solver:fzn_ic,fzn_tmp:file}, FznFile).\n    FznFile = \"mymodel.fzn\"\n    Yes (0.00s cpu)\n"]).
:- comment(mzn_load / 5, [summary : "Load a MiniZinc model from a file", amode : (mzn_load(++, ++, ++, +, -) is semidet), args : ["ModelFile" : "File name (extension defaults to .mzn)", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "InstFileOrParMap" : "Instance file name (extension defaults to .dzn), or list of FznId=ECLiPSeGroundTerm correspondences", "VarMap" : "List of FznId=ECLiPSeVarTerm correspondences", "FznState" : "FlatZinc state descriptor"], fail_if : "Fails if the constraint setup fails", see_also : [mzn_run / 2, mzn_run / 3, mzn_load_string / 5, struct(zn_options)], desc : html("<P>\n\tLoads a MiniZinc from ModelFile.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    </P><P>\n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n\tAlternatively, an instance file can be specified.\n    </P><P>\n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    </P><P>\n    \tThe mzn_load/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    </P>"), eg : "\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n\n    ?- mzn_load(\"queens\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4];\n    % Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n"]).
:- comment(mzn_load_string / 5, [summary : "Load a MiniZinc model given as a string or list", amode : (mzn_load_string(++, ++, ++, +, -) is semidet), args : ["MznModel" : "String, Atom or List of constants", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure", "ParMap" : "List of FznId=ECLiPSeGroundTerm correspondences", "VarMap" : "List of FznId=ECLiPSeVarTerm correspondences", "FznState" : "FlatZinc state descriptor"], fail_if : "Fails if the constraint setup fails", see_also : [mzn_run / 2, mzn_run / 3, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tLoads the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZinc syntax.  The problem is set up using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Neither search nor output are done.\n    </P><P>\n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    </P><P>\n\tTo pass parameters into the model, a ParMap can be given, consisting\n\tof a list of FznId=ECLiPSeGroundTerm correspondences.  Here, FznId\n\tis an atom (the FlatZinc parameter identifier within the model),\n\tand ECLiPSeGroundTerm is the corresponding ECLiPSe constant.\n    </P><P>\n    \tTo access the ECLiPSe variables corresponding to the model's\n\tvariables, VarMap can be given, consisting of a list of\n\tFznId=ECLiPSeTerm correspondences.  Here, FznId is an atom\n\t(the FlatZinc variable identifier within the model), and\n\tECLiPSeTerm is the corresponding ECLiPSe constant, variable\n\tor array.\n    </P><P>\n    \tThe mzn_load_string/5 predicate returns a FlatZinc solver\n\tstate which can be used to lookup further information about\n\tthe model (fzn_var_lookup/3, fzn_obj_lookup/2), to perform\n\tthe standard search (fzn_search/1), or to perform the model's\n\toutput actions (fzn_output/1).\n    </P>"), eg : "\n    ?- mzn_load_string(\"\n\t\tint: n;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \",\n\t    fzn_ic,\n\t    [n=8],\n\t    [q=Q],\n\t    FznState).\n\n    Q = [](_2492{1..8}, _2512{1..8}, _2532{1..8}, _2552{1..8}, ...]\n    FznState = state(...)\n    There are 84 delayed goals.\n    Yes (0.02s cpu)\n\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q).\n\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n\n\n    ?- mzn_load_string(\"...\", fzn_ic, [n=8], [q=Q], FznState),\n       ic:labeling(Q),\n       fzn_output(FznState).\n\n    % output from fzn_output:\n    q = [1,5,8,6,3,7,2,4];\n    % Total time 0.030s cpu (0.020 setup)\n\n    % output from ECLiPSe toplevel:\n    Q = [](1, 5, 8, 6, 3, 7, 2, 4)\n    FznState = state(...)\n    Yes (0.03s cpu, solution 1, maybe more)\n</PRE>\n"]).
:- comment(mzn_run / 0, [summary : "Run a MiniZinc model using command line arguments", amode : (mzn_run is det), args : [], see_also : [mzn_run / 2, mzn_run / 3, struct(zn_options)], desc : html("<P>\n    Runs a MiniZinc model, taking all the necessary parameters from\n    the process command line.  The recommended way to use this\n    predicate is by calling eclipse from a command line as:\n<PRE>\n        eclipse -e minizinc:mzn_run -- [&lt;options&gt;] &lt;model&gt;.mzn [&lt;data&gt;.dzn]\n</PRE>\n    (note the <CODE>--</CODE> that separates eclipse's own arguments from\n    the arguments interpreted by mzn_run/0).\n</P><P>\n    The following options are recognized:\n<DL>\n    <DT>&lt;model&gt;.mzn</DT><DD>\n        a minizinc model file, with mandatory .mzn extension.\n    </DD>\n    <DT>&lt;data&gt;.dzn</DT><DD>\n        a minizinc data file, with mandatory .dzn extension.\n    </DD>\n    <DT>-a</DT><DD>\n        compute all solutions. This is currently only meaningful with \n\tsatisfaction problems.\n    </DD>\n    <DT>-b &lt;solver&gt;</DT><DD>\n        selects the solver backend (fzn_ic, fzn_eplex, fzn_fd).\n        The default is fzn_ic.\n    </DD>\n    <DT>-d &lt;datafile&gt;</DT><DD>\n        an alternative way to specify a data file.\n    </DD>\n    <DT>-n &lt;num&gt;</DT><DD>\n        compute at most the given number of solutions.  This is currently\n\tonly meaningful with satisfaction problems.  Default is 1.\n    </DD>\n    <DT>--no-optimize</DT><DD>\n        pass the --no-optimize option to mzn2fzn, which can improve\n\tperformance on large models.\n    </DD>\n    <DT>--no-log</DT><DD>\n        suppress all output printed to the log_output stream.  Equivalent\n\tto calling set_stream(log_output,null).\n    </DD>\n    <DT>-o &lt;outputfile&gt;</DT><DD>\n        redirect regular solver output to the given file.  Note that\n\tlog_output, warning_output and error output are not redirected.\n    </DD>\n    <DT>--raw</DT><DD>\n        print the raw flatzinc output (corresponding to the flatzinc output\n\tannotations) instead of the postprocessed (via solns2out) output\n\tcorresponding to the minizinc output items.\n    </DD>\n    <DT>-s</DT><DD>\n        after each solution, print a statistics-comment as part of the\n\toutput.  Without this option, this information goes to the log_output\n\tstream, which can be suppressed if desired.\n    </DD>\n    <DT>-t &lt;seconds&gt;</DT><DD>\n        solver timeout in seconds.  This does not apply to the Minizinc-to-\n\tFlatzinc translation (mzn2fzn), but only to the solver setup and\n\tsearch phases.  With satisfaction problems, a timeout may lead to\n\tfewer solutions, with optimization problems to a suboptimal solution,\n\tor no solution at all.\n    </DD>\n</DL>\n    Note: currently, only a single data file can be specified.\n    </P>"), eg : "\n   $ eclipse -e minizinc:mzn_run -- --no-log -a send-more-money.mzn \n      9567\n   +  1085\n   = 10652\n   ----------\n   ==========\n"]).
:- comment(mzn_run / 2, [summary : "Run a MiniZinc model from a given file", amode : (mzn_run(+, ++) is det), args : ["File" : "File name (extension defaults to .mzn)", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [fzn_run / 2, mzn_run / 3, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tReads a MiniZinc model from a file, and interprets it using\n\tthe solver mapping defined in SolverOrOptions.  At the end of\n\tsolving, results are printed to the output stream, timing and\n\tprogress messages are printed to the log_output stream, warnings\n\tto the warning_output stream, and error messages the error stream.\n\tThis predicate always succeeds.\n    </P>"), eg : "\n    ?- mzn_run(\"mymodel.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(queens8, zn_options{solver:fzn_ic,solutions:3}).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,6,8,3,7,4,2,5]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n    q = [1,7,4,6,8,2,5,3]\n    Total time 0.016s cpu (0.016 setup + 0.000 search)\n"]).
:- comment(mzn_run / 3, [summary : "Run a MiniZinc model from a given model and instance file", amode : (mzn_run(+, +, ++) is det), args : ["ModelFile" : "File name (extension defaults to .mzn)", "InstFileOrParMap" : "Instance file name (extension defaults to .dzn), or list of Id=Term correspondences", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [mzn_run / 2, mzn_run_string / 2, struct(zn_options)], desc : html("<P>\n\tReads a MiniZinc model (given a model file and an instance\n\tfile) and interprets it using the solver mapping defined in\n\tSolverOrOptions.  At the end of solving, results are printed\n\tto the output stream, timing and progress messages are printed\n\tto the log_output stream, warnings to the warning_output\n\tstream, and error messages the error stream.  This predicate\n\talways succeeds.\n    </P>"), eg : "\n    ?- mzn_run(\"mymodel.mzn\", \"myinstance.mzn\", fzn_ic).\n    Found a solution with cost 10\n    Found no solution with cost 7.0 .. 9.0\n    end = 10\n    b1 = 1\n    b2 = 0\n    b3 = 1\n    b4 = 0\n    Objective value = 10\n    Total time 0.031s cpu (0.016 setup + 0.000 search)\n\n    ?- mzn_run(\"queens.mzn\", [n=8], fzn_ic).\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.015s cpu (0.000 setup + 0.000 search)\n"]).
:- comment(mzn_run_string / 2, [summary : "Run a MiniZinc model given as a string or list", amode : (mzn_run_string(++, ++) is det), args : ["MznModel" : "String, Atom or List of constants", "SolverOrOptions" : "Name of solver mapping module, or zn_options-structure"], see_also : [mzn_run / 2, mzn_run / 3, struct(zn_options)], desc : html("<P>\n\tSolves the MiniZinc model MznModel, given in the simplest form\n\tas a string in MiniZInc syntax.  The problem is solved using\n\ta mapping to a concrete ECLiPSe solver, as specified in the\n\tSolverOrOptions argument.  Search and output are done according\n\tto the model's solve and output items.\n    </P><P>\n\tNote that, because of the rules for escaping characters within\n\tECLiPSe strings, any backslashes in the MiniZinc source have\n\tto be doubled, and double quotes must be escaped with a backslash!\n    </P><P>\n\tObviously, one would like to pass parameters into a model.  The\n\tmodel can therefore  be given as a list of strings in MiniZinc\n\tsyntax, interleaved with ECLiPSe ground terms that serve as \n\tparameter instantiations.  The actual MiniZinc model then\n\tconsists of the concatenation of all these parts.\n    </P>"), eg : "\n    ?- mzn_run_string(\"\n\t\tint: n = 8;\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \", fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    Yes (0.02s cpu, solution 1, maybe more)\n\n\n    ?- N=8, mzn_run_string([\"\n\t\tint: n = \",\n\t    N, \";\n\t\tarray [1..n] of var 1..n: q;\n\t\tconstraint\n\t\t    forall (i in 1..n, j in i+1..n) (\n\t\t\tq[i]     != q[j]     /\\\\\n\t\t\tq[i] + i != q[j] + j /\\\\\n\t\t\tq[i] - i != q[j] - j\n\t\t    );\n\t\tsolve satisfy;\n\t    \"], fzn_ic).\n\n    Starting search\n    q = [1,5,8,6,3,7,2,4]\n    Total time 0.020s cpu (0.020 setup+ 0.000 search)\n    N = 8\n    Yes (0.02s cpu, solution 1, maybe more)\n</PRE>\n"]).
