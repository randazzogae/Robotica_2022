:- module(cycle).
:- export cycle / 4.
:- export cycle / 3.
:- comment(categories, ["Constraints"]).
:- comment(summary, "Cycle constraint").
:- comment(author, "Lukasz Domagala").
:- comment(copyright, "www.redber.pl").
:- comment(date, "2010/06/05 21:41").
:- comment(desc, ascii("\r\n\tA configurable constraint that forces the existence of a Hamiltonian cycle in a directed graph.\r\n\tThe constraint uses the ic and eplex libraries to achieve different levels of filtering. For more \r\n\tdetails see cycle/4.\r\n\tParts of the filtering algorithm have been inspired by or are implementations of ideas presented by\r\n\tJohn H.Hooker in \"Rossi F., van Beek P., Walsh T. (Eds.), Handbook of Constraint Programming, \r\n\tchap. 15. 2006 Elsevier.\".\r\n\t\r\n\tThe constraint will be refined and new filtering techniques will be added as time will allow to\r\n\twork on the subject.\r\n\t")).
:- comment(eg, "\t\r\n:-lib(cycle).\r\n:-lib(ic).\r\n:-lib(branch_and_bound).\t\r\ncycle_example:-\r\n\t%edge weight matrix, \r\n\t%the example data has been provided by Prof. Antoni Niederli\361ski\r\n\tEdgeWeightMx=[](\r\n\t\t[](  0,384,484,214,234,267,524,656,446,371,459,561,585,683,634,751),\r\n\t\t[](384,  0,156,411,296,167,339,379,340,432,485,545,483,500,565,642),\r\n\t\t[](484,156,  0,453,323,217,213,223,281,442,452,479,394,370,500,516),\r\n\t\t[](214,411,453,  0,130,259,413,601,303,157,245,356,422,542,427,585),\r\n\t\t[](234,296,323,130,  0,129,310,491,212,178,261,335,354,465,403,517),\r\n\t\t[](267,167,217,259,129,  0,255,389,205,265,318,391,348,421,430,516),\r\n\t\t[](524,339,213,413,310,255,  0,188,134,344,319,297,181,161,295,303),\r\n\t\t[](656,379,223,601,491,389,188,  0,322,532,507,485,363,260,477,430),\r\n\t\t[](446,340,281,303,212,205,134,322,  0,204,181,196,143,242,220,306),\r\n\t\t[](371,432,442,157,178,265,344,532,204,  0, 86,199,300,428,268,433),\r\n\t\t[](459,485,452,245,261,318,319,507,181, 86,  0,113,220,382,182,347),\r\n\t\t[](561,545,479,356,335,391,297,485,196,199,113,  0,156,323, 75,244),\r\n\t\t[](585,483,394,422,354,348,181,363,143,300,220,156,  0,167,114,163),\r\n\t\t[](683,500,370,542,465,421,161,260,242,428,382,323,167,  0,269,170),\r\n\t\t[](634,565,500,427,403,430,295,477,220,268,182, 75,114,269,  0,165),\r\n\t\t[](751,642,516,585,517,516,303,430,306,433,347,244,163,170,165,  0)\r\n\t),\r\n\t%the cities are: Szczecin,Gda\361sk,Olsztyn,Zielona G\363ra,Pozna\361,Bydgoszcz,Warszawa,\r\n\t%Bia\263ystok,\243\363dz,Wroc\263aw,Opole,Katowice,Kielce,Lublin,Krak\363w,Rzesz\363w.\r\n\t\r\n\tdim(EdgeWeightMx,[CityCount,CityCount]),\r\n\tlength(EdgeDstCityLi,CityCount),\r\n\t%the edge variables' domains, any city can be reached from any other \r\n\tic:(EdgeDstCityLi#::1..CityCount),\t\r\n\t%the edges (i,j) where i==j will be removed by the constraint\r\n\tcycle(EdgeDstCityLi,EdgeWeightMx,SumOfEdgeWeights),\t\r\n\r\n\t%search\r\n\tcputime(StartTime),\r\n\tSearchGoal=search(EdgeDstCityLi, 0, most_constrained, indomain_max, complete, []),\r\n\tbb_min(SearchGoal, SumOfEdgeWeights, bb_options{strategy:dichotomic}),\r\n\tcputime(EndTime),\r\n\tSearchTime is EndTime - StartTime,\r\n\t\r\n\t%print result\r\n\tprintf(\"Search time=%2.2fs  \",[SearchTime]),printf(\"Cost=%w\",[SumOfEdgeWeights]),nl,\t\r\n\twrite(\"Edges=\"),writeln(EdgeDstCityLi),\r\n\ttrue.\t\r\n\t").
:- comment(cycle / 3, [amode : (cycle(+, ++, -) is semidet), args : ["Edges" : "A list of ic variables", "EdgeWeights" : "A square matrix of integers", "CycleCost" : "The cost of the cycle"], summary : "A constraint that forces a Hamiltonian cycle in a directed graph", desc : ascii("\r\n\tEdges is a list of length VertexCount of ic variables, where VertexCount is the number of \r\n\tvertices in the graph. Each variable needs to have a domain which is the subset of \r\n\t[1..VertexCount]. The values in the i-th variable's domain correspond to edges in the \r\n\tgraph, so the domain value j of the i-th variable corresponds to an edge (i,j). \r\n\r\n\tEdgeWeights is a square matrix (array of arrays) of size VertexCount*VertexCount of nonnegative \r\n\tintegers. The value indexed [i,j] corresponds to the cost of the edge (i,j). Values on the diagonal\r\n\t([i,i]) are unimportant since the correspond to edges (i,i) which are automatically removed by\r\n\tthe constraint.\r\n\r\n\tCycleCost is an ic variable that corresponds to the cost of the cycle. \r\n\r\n\tThis version of the constraint uses the maximal propagation level. For more details and \r\n\tconfiguration of different propagation levels see cycle/4. \r\n\t\t"), see_also : [cycle / 4], fail_if : "It is impossible to find any Hamiltonian cycle in the graph", exceptions : [1 : "Wrong edge weigh matrix size.", 1 : "Wrong edge list length.", 6 : "Wrong edge domain values.", 1 : "Wrong weight value.", 8 : "Unknown options"]]).
:- comment(cycle / 4, [amode : (cycle(+, ++, -, ++) is semidet), args : ["Edges" : "A list of ic variables", "EdgeWeights" : "A square matrix of integers", "CycleCost" : "The cost of the cycle", "Configuration" : "A list of key:value configuration elements"], summary : "A constraint that forces a Hamiltonian cycle in a directed graph", desc : ascii("\r\n\tEdges is a list of length VertexCount of ic variables, where VertexCount is the number of \r\n\tvertices in the graph. Each variable needs to have a domain which is the subset of \r\n\t[1..VertexCount]. The values in the i-th variable's domain correspond to edges in the \r\n\tgraph, so the domain value j of the i-th variable corresponds to an edge (i,j). \r\n\r\n\tEdgeWeights is a square matrix (array of arrays) of size VertexCount*VertexCount of nonnegative \r\n\tintegers. The value indexed [i,j] corresponds to the cost of the edge (i,j). Values on the diagonal\r\n\t([i,i]) are unimportant since the correspond to edges (i,i) which are automatically removed by\r\n\tthe constraint.\r\n\r\n\tCycleCost is an ic variable that corresponds to the cost of the cycle. \r\n\r\n\tConfiguration is a list of key:value pairs that configure the filtering level of the constraint. \r\n\trc_varfix:yes/no (default is yes), enables or disables the propagation of reduced cost variable \r\n\tfixing constraints. These constraints are based on the solution of the LP relaxation for the cycle. \r\n\tcut_planes:yes/no (default is yes), enables or disables the iterative strengthening of the LP \r\n\trelaxation by generation of cutting planes for the LP model. \r\n\tbound_upd:yes/no (default is yes), enables or disables the tightening of the upper bound on cost \r\n\tby solving a LP relaxation. \r\n\topt_dir:min/max (default is min), the propagation is optimised for minimisation (min) \r\n\tor maximisation (max) of the CycleCost. \r\n\r\n\tThe default configuration for the constraint is to use the maximal available propagation \r\n\tand cost tightening. This setting is also used by the cycle/3. \r\n\r\n\tThe most basic propagation level for cycle is achieved by setting\r\n\tConfiguration=[rc_varfix:no,cut_planes:no,bound_upd:no].\r\n\t\r\n\t\t"), see_also : [cycle / 3], fail_if : "It is impossible to find any Hamiltonian cycle in the graph", exceptions : [1 : "Wrong edge weigh matrix size.", 1 : "Wrong edge list length.", 6 : "Wrong edge domain values.", 1 : "Wrong weight value.", 8 : "Unknown options"]]).
