:- module(fd_global_gac).
:- export alldifferent / 1.
:- export matching / 2.
:- export gcc / 2.
:- export same / 2.
:- export inverse / 2.
:- export lex_le / 2.
:- export lex_lt / 2.
:- export tr_global_gac_out / 2.
:- export portray(update_alldifferent / 4, tr_global_gac_out / 2, [goal]).
:- export alldifferent_matrix / 1.
:- export gcc_matrix / 3.
:- reexport sequence / 5, sequence / 4 from fd_sequence.
:- reexport table / 2, mddc / 2 from ic_mdd.
:- comment(categories, ["Constraints", "Algorithms"]).
:- comment(summary, "Library of global constraints which achieve generalized arc consistency").
:- comment(desc, html("<P>\n    This library is intended for global constraints for which GAC\n    (generalized arc consistency, also called hyper arc consistency,\n    or domain consistency) is maintained.  One example is a version\n    of the alldifferent constraint which performs more pruning than\n    the bound consistent version in the fd_global library.\n    </P><P>\n    If a program uses multiple libraries, more than one version (with\n    different degrees of propagation strength) of the declaratively\n    same constraint may be visible.  In this case, the programmer has\n    to explicitly state which version is wanted, either by using an\n    import directive such as\n    <PRE>\n        :- import alldifferent/1 from fd_global_gac.\n    </PRE>\n    or by module-qualifying individual calls, such as\n    <PRE>\n        ..., fd_global_gac:alldifferent(Xs), ...\n    </PRE>\n    </P>")).
:- comment(author, "H. Simonis, 4C, University College Cork").
:- comment(copyright, "2008, H. Simonis, 4C, University College Cork").
:- comment(status, prototype).
:- comment(date, "2008").
:- comment(alldifferent / 1, [summary : "GAC version of alldifferent", amode : alldifferent(+), args : ["L" : "List of integers or domain variables, or a collection a la collection_to_list/2"], kind : [constraint : [root : [ic, fd]]], desc : html("This predicate implements a GAC (generalized arc consistency) version of the alldifferent constraint. It uses the classical bitpartite matching implementation using the graph_algorithms library. This version often removes more values than the bound consistent alldifferent in the ic_global library, or the forward checking variant in the ic library, but may spend much more time doing this."), fail_if : "fails if there is no bipartite matching between all variables and the possible values", see_also : [matching / 2, ic : alldifferent / 1, ic_global : alldifferent / 1]]).
:- comment(alldifferent_matrix / 1, [summary : "Constrain the rows and columns of Matrix to be different values", amode : alldifferent_matrix(+), args : ["Matrix" : "A two dimensional square matrix of Variables or integer"], see_also : [fd_global_gac : alldifferent / 1, _109725 : alldifferent_matrix / 1], kind : [constraint : [root : fd]], desc : html("<P>\n    This constraint is a matrix version of alldifferent. Matrix is a two\n    dimensional square (NxN) matrix, and the constraint ensures that the \n    elements in each row and column of the matrix are different. The same\n    value can occur in different rows and columns. It is logically \n    equivalent to imposing 2N alldifferent constraints on each row and column,\n    but it allows more reasoning because it consider the rows and columns \n    together. The version uses alldifferent from lib(fd_global_gac), but the \n    extra inferences performed between the rows and columns themselves not be\n    fully domain consistent. The maximum propagation occurs when the \n    variables' domains also have N values. \n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n")]).
:- comment(gcc / 2, [amode : gcc(++, +), args : ["Bounds" : "A list of elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values", "Vars" : "A collection of different variables or integers"], summary : "Constrain the cardinality of each Value specified in Bounds gcc(Low,High,Value) to be between Low and High in Vars", kind : [constraint : [root : [ic, fd]]], desc : html("<P>\n    This constraint ensures that the cardinality (the number of occurrences)\n    of values in Vars conforms to the specifications in Bounds. Bounds is a\n    list of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in Bounds, and whose cardinality |Value| is specified by \n    Low =< |Value| =< High, where Low and High are non-negative integers.\n    Note that all values that Vars can take must be specified in Bounds.\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n    This constraint is known as global_cardinality_low_up in the global\n    constraint catalog. The algorithm implemented is described in \n    J.-C. Regin's paper 'Generalized Arc Consistency for Global Cardinality\n    Constraint', published in AAAI-1996. \n")]).
:- comment(gcc_matrix / 3, [summary : "Constrain the cardinality of values taken in the rows and columns of Matrix as specified by RowBounds and ColBounds, respectively", amode : gcc_matrix(++, ++, +), args : ["RowBounds" : "A list of M sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in RowBounds", "ColBounds" : "A list of N sublists with elements of the form gcc(Low,High,Value), where Low, High and Value are integers, and High and Low are non-negative (High >= Low), and Value must be different from other Values in ColBounds", "Matrix" : "A two dimensional MxN matrix of Variables or integer"], see_also : [fd_global_gac : gcc / 2], kind : [constraint : [root : fd]], desc : html("    This constraint ensures that the cardinality (the number of occurrences)\n    of values in each row and column of Matrix conforms to the specifications\n    in RowBounds and ColBounds, respectively. RowBounds and ColBounds are \n    lists of triples in the form gcc(Low,High,Value) where Value is an integer,\n    a value that Vars is to be assigned to, and must occur only once as a\n    Value in the row/column, and whose cardinality |Value| is specified by \n    Low =< |Value| =< High, where Low and High are non-negative integers. \n    Vars cannot take values not specified in a gcc triplet.\n    This constraint is logically equivalent to imposing M+N individual gcc\n    constraints, on each row and column of Matrix, but allows more reasoning\n    because of the interaction of the values between the rows and columns.\n    The gcc used is from lib(fd_global_gac), but the extra inferences \n    performed between the rows and columns themselves may be not fully \n    domain consistent. \n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n    This constraint is described in J.-C. Regin and C. Gomes,\n    'The Cardinality Matrix Constraint', CP 2004.\n")]).
:- comment(inverse / 2, [amode : inverse(+, +), args : ["Succ" : "A collection of N different variables or integers", "Pred" : "A collection  of N different variables or integers"], summary : "Constrains elements of Succ to be the successors and Pred to be the predecessors of nodes in a digraph", kind : [constraint : [root : [ic, fd]]], desc : html("<P>\n     Succ and Pred are list of N elements, representing a digraph of N nodes,\n     where the i'th element of Succ and Pred represents the successor and\n     predecessor of the node i respectively. The constraint enforces each\n     node in the digraph to have one successor and one predessor node, and\n     that if node y is the successor of node x, then node x is the\n     predecessor of node y.\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n     This constraint is known as inverse in the global constraint catalog,\n     but with implicit node index based on the position in the list.  \n")]).
:- comment(lex_le / 2, [summary : "List1 is lexicographically less or equal to List2", amode : lex_le(+, +), args : ["List1" : "List of integers or domain variables", "List2" : "List of integers or domain variables"], kind : [constraint : [root : [ic, fd]]], desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e. either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached)is strictly smaller than any existing element.\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n        This constraint is known as lex_lesseq in the global constraint\n        catalog. The implementation here maintains generalised arc\n        consistency and uses the algorithm described in:\n        Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n        Uppsala University, 2004.\n")]).
:- comment(lex_lt / 2, [summary : "List1 is lexicographically less than  List2", amode : lex_lt(+, +), args : ["List1" : "List of integers or domain variables", "List2" : "List of integers or domain variables"], kind : [constraint : [root : [ic, fd]]], desc : html("    \tImposes a lexicographic ordering between the two lists. \n\tI.e.  either is the first element of List1 strictly smaller\n\tthan the first element of List2, or the first elements are\n\tequal and the lexicographic order holds between the two list\n\ttails. A non-existing element (i.e. when the end of list is \n        reached)is strictly smaller than any existing element.\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n        This constraint is known as lex_less in the global constraint\n        catalog. The implementation here maintains generalised arc\n        consistency and uses the algorithm described in:\n        Z. Kiziltan, 'Symmetry Breaking Ordering Constraints, Ph.D thesis,\n        Uppsala University, 2004.\n")]).
:- comment(matching / 2, [summary : "Get a matching between a list of domain variables and their possible values", amode : matching(+, -), args : ["L" : "A list of integers or domain variables, or a collection a la collection_to_list/2", "K" : "A free variable, will be bound to a list of integers"], fail_if : "The predicate fails if no matching exists", desc : html("This predicate can be used to get the matching into the user program. Sometimes it is a good starting point for heuristics. It only gets the current matching and does not do any propagation, the matching is not updated when values are removed, the predicate must be called again in the user program if this is required"), see_also : [alldifferent / 1]]).
:- comment(same / 2, [amode : same(+, +), args : ["Vars1" : "A collection of N different variables or integers", "Vars2" : "A collection of N different variables or integers"], summary : "Vars1 and Vars2 are constrained to be a permutation of each other in the values taken by the variables.", kind : [constraint : [root : [ic, fd], extra : [gccat : same]]], desc : html("<P>\n    This constraint ensures that the values taken by the variables in Vars1\n    and Vars2 are permutations of each other. Vars1 and Vars must be the same\n    length.\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n    This constraint is also known as same in the global constraint catalog. \n    The implementation is the generalised arc-consistent version described\n    in the catalog. \n")]).
:- comment(sequence / 4, [amode : sequence(+, +, +, +), args : ["Low" : "Non-negative integer", "High" : "Positive integer", "K" : "Postive integer", "ZeroOnes" : "A collection of 0/1 variables or integers"], summary : "The number of occurrences of the value 1 is between Low and High for all sequences of K variables in ZeroOnes", see_also : [fd_global_gac : sequence / 5, fd : element / 3, fd_global : sequence_total / 6, fd_global : sequence_total / 7], kind : [constraint : [root : fd]], desc : html("<P>\n    This constraint ensures that the number of occurrences of the value 1\n    is at least Low and at most High for all sequences of K consecutive \n    variables/values in ZeroOnes. ZeroOnes are 0/1 variables (or itnegers), \n    i.e. they have the domain [0,1]. \n</P><P>\n    The ZeroOnes can be interpreted as the fulfillment of various\n    conditions if the variables are linked to these conditions. For example,\n    sequence/5 is implemented by linking the N ZeroOnes variables to a \n    matching collection of N finite domain `original' variables using \n    element/3 constraints to constrain the ZeroOnes to be 1 if the \n    corresponding original value takes one of the specified values. The\n    ZeroOnes can then be used in further constraint reasoning.\n</P><P>\n    Note: this constraint is different from sequence/4 in lib(fd).\n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n")]).
:- comment(sequence / 5, [amode : sequence(+, +, +, +, ++), args : ["Low" : "Non-negative integer", "High" : "Positive integer", "K" : "Postive integer", "Vars" : "A list of variables or integers", "Values" : "A list of (different) integers"], summary : "The number of values taken from Values is between Low and High for all sequences of K variables in Vars.", see_also : [fd_global_gac : sequence / 5, fd : element / 3, fd_global : sequence_total / 6, fd_global : sequence_total / 7], kind : [constraint : [root : fd]], desc : html("<P>\n    This constraint ensures that the number of values taken from the set\n    specified in Values is at least Low and at most High for all sequences \n    of K consecutive variables/values in Vars. \n</P><P>\n    This is currently a prototype -- the constraint has not been tested\n    very extensively and little effort has been spent to optimise performance.\n    We welcome any feedback on using this constraint.\n</P><P>\n    This constraint is known as among_seq in the global constraint catalog.\n    The algorithm implemented is described in M. Maher et al.'s paper \n    'Flow-Based Propagators for the SEQUENCE and Related Global Constraints' \n    in CP'2008.\n")]).
:- comment(tr_global_gac_out / 2, hidden).
