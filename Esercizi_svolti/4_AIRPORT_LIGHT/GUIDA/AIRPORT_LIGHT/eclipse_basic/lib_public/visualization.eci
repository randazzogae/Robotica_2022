:- module(visualization).
:- export create_visualization / 2.
:- export add_visualizer / 3.
:- export draw_visualization / 1.
:- export draw_visualization / 2.
:- export close_visualization / 1.
:- comment(author, "Helmut Simonis").
:- comment(status, "experimental").
:- comment(copyright, "2010, Helmut Simonis").
:- comment(categories, ["Development Tools", "Visualisation"]).
:- comment(summary, "Definition of the log format for constraint and variable visualizers").
:- comment(description, "This library describes how variable and constraint visualizers record their information in the log files. It also provides predicates to start and stop the visualization process. The library is re-exported by visualize_tree, it does not need to be loaded independently").
:- comment(add_visualizer / 3, [summary : "Add a visualizer to the visualisation", args : ["Handle" : "an opaque data structure for the visualization", "Visualizer" : "a term, defining the visualizer", "Options" : "a list of option:value pairs describing the options to be applied to the visualizer"], amode : add_visualizer(+, ++, ++), desc : html("<P>\r\nThis predicate is used to add a visualizer to an existing\r\nvisualization.  It can be called after the visualization has been\r\ncreated with a create_visualization/2 call.  The second argument is\r\nthe description of the visualizer, either for variables or for\r\nconstraints.\r\n</P><P>\r\nVariable visualizers display the state and/or evolution of a\r\ncollection of variables.  At the moment this can be one of the\r\nfollowing entries:\r\n\r\n<table border=1>\r\n<tr>\r\n<td>Variable Visualizer</td>  <td>Description</td>\r\n</tr>\r\n<tr>\r\n<td>vector(L)</td>  <td>The visualizer shows the current state of a\r\ncollection of variables.  It marks which variables have been assigned,\r\nwhich values have been removed and which values remain in the domain.</td>\r\n</tr>\r\n<tr>\r\n<td>vector_waterfall(L)</td>  <td>This visualizer shows the changes of\r\nthe collection of variables on the path from the root node to the\r\ncurrent node.  It marks if a variable is assigned, changed (min and\r\nmax, min, max or size only), or if it is not modified in each step.</td>\r\n</tr>\r\n<tr>\r\n<td>vector_size(L)</td>  <td>This visualizer shows the change of the\r\ndomain sizes for a collection of variables from the root node to the\r\ncurrent node in the search.</td>\r\n</tr>\r\n<tr>\r\n<td>binary_vector(Bool)</td>  <td>This visualizer is a special variant\r\nof the vector visualizer for a collection of 0/1 vairables.  Values\r\nare marked either as unassigned, or as assigned to zero or to one.</td>\r\n</tr>\r\n<tr>\r\n<td>domain_matrix(Matrix)</td>  <td>This visualizer shows a 2D matrix of\r\ndomain variables.  Depending on the options, it only shows the\r\nassigned values, or displayed the values remaining in the domain.</td>\r\n</tr>\r\n<tr>\r\n<td>binary_matrix(BoolMatrix)</td>  <td>A specialized version of the\r\nmatrix visualizer for 0/1 variables.</td>\r\n</tr>\r\n</table>\r\n\r\n</P><P>\r\nConstraint visualizers show the state and/or evolution of a global\r\nconstraint.  At the moment, visualizers for the following global\r\nconstraints are provided.\r\n\r\n<table border=1>\r\n<tr>\r\n<td>Constraint Visualizer</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>alldifferent(Xs)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>alldifferent_matrix(Matrix)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>bin_packing(Items,Sizes,Bins)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>bool_channeling(X,Bool,Start)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>cumulative(Starts,Durations,Resources,Limit)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>cumulative(Starts,Durationss,Resources,Limit,End)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>disjoint2(Rectangles)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>element(X,Vs,Y)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>gcc(Limits,Vars)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>gcc_matrix(RowLimits,ColLimits,Matrix)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>inverse(Succ,Pred)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>lex_le(Xs,Ys)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>lex_lt(Xs,Ys)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>same(Xs,Ys)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td>sequence_total(Min,Max,Low,Hi,K,ZeroOnes)</td><td></td>\r\n</tr>\r\n<tr>\r\n<td></td><td></td>\r\n</tr>\r\n</table>\r\n\r\n</P><P>\r\nPossible Options are:\r\n<DL>\r\n<DT>display</DT><DD>\r\n    influences how the visualizer will be drawn (expanded, text, gantt, ...),\r\n    default: minimal\r\n<DT>group</DT><DD>\r\n    group id number for the visualizer (integer, or 'other')\r\n<DT>x,y</DT><DD>\r\n    position at which the visualizer will be placed (default 0,0)\r\n</DD>\r\n</DL>\r\n</P>\r\n"), eg : ascii("top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n"), see_also : [alldifferent / 1, alldifferent_matrix / 1, bin_packing / 3, bool_channeling / 3, cumulative / 4, element / 3, gcc / 2, gcc_matrix / 3, inverse / 2, lex_le / 2, lex_lt / 2, same / 2, sequence_total / 6, create_visualization / 2, close_visualization / 1, solution / 1, try / 4, failure / 4, tree_indomain / 3, draw_visualization / 1]]).
:- comment(close_visualization / 1, [summary : "Stop the visualization, close all log files and flush all file output", args : ["Handle" : "an opaque data structure for the visualization"], amode : close_visualization(+), desc : html("This predicate should be called at the end of a program to close the visualization logs, flush all file output and reset the internal data structures."), eg : ascii("top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n"), see_also : [solution / 1, try / 4, failure / 4, tree_indomain / 3, visualization : draw_visualization / 1]]).
:- comment(create_visualization / 2, [summary : "Prepare to generate visualization output", args : ["Options" : "a list of option pairs of form option:value", "Handle" : "a free variable, will be bound to an opaque data structure for the visualization"], amode : create_visualization(+, -), desc : html("<P>This predicate prepares the system for visualization output and create a data structure Handle which is used by all other visualization predicates. For every run, the predicate should only be called once. It can not be called again, until the current visualization is closed with close_visualization/1. The predicate only prepares the system, it does not record a execution state on its own.</P><P>Possible options are:<DL><DT>output</DT><DD>   atom/string (default 'OUTPUT'), name of directory where log files will be placed</DD><DT>ignore_fixed</DT><DD>    yes/no (default yes), states if fixed assignments will be ignored and not create tree nodes</DD></DL></P>"), eg : ascii("top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    number_variables(Handle,L,Terms),\n    root(Handle),\n    search(Terms,1,first_fail,tree_indomain(Handle,_),complete,[]),\n    solution(Handle),\n    close_visualization(Handle).\n"), see_also : [root / 1, solution / 1, try / 4, failure / 4, tree_indomain / 3, draw_visualization / 1, close_visualization / 1]]).
:- comment(draw_visualization / 1, [summary : "Log the current state of the constraint system", args : ["Handle" : "an opaque data structure for the visualization"], amode : draw_visualization(+), desc : html("This predicate is used to explicitely log the state of the constraint systems for visualization. It is used by the application programmer to show the effect of some setup steps, before the search is started. It is also called automatically by the tree logging predicates, so that a user rarely needs to call it inside a search routine."), eg : ascii("top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    draw_visualization(Handle),\n    close_visualization(Handle).\n"), see_also : [root / 1, solution / 1, try / 4, failure / 4, tree_indomain / 3, draw_visualization / 2]]).
:- comment(draw_visualization / 2, [summary : "Log the current state of the constraint system", args : ["Handle" : "an opaque data structure for the visualization", "Options" : "a list of option:value pairs"], amode : draw_visualization(+, +), desc : html("This predicate is used to explicitely log the state of the constraint systems for visualization, i.e. create a visualisation time point. It is used by the application programmer to show the effect of some setup steps, before the search is started. It is also called automatically by the tree logging predicates, so that a user rarely needs to call it inside a search routine."), eg : ascii("top(N,L):-\n    length(L,N),\n    L :: 1..N,\n    alldifferent(L),\n    create_visualization([],Handle),\n    add_visualizer(Handle,vector(L),[]),\n    draw_visualization(Handle,[]),\n    close_visualization(Handle).\n"), see_also : [root / 1, solution / 1, try / 4, failure / 4, tree_indomain / 3, draw_visualization / 1]]).
