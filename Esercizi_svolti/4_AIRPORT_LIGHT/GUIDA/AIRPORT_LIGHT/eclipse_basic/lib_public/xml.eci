:- module(xml).
:- export xml_parse / 2.
:- export xml_parse / 3.
:- export xml_subterm / 2.
:- export xml_pp / 1.
:- comment(include, xml_comments).
:- comment(categories, ["Interfacing"]).
:- comment(summary, 'A bi-directional XML parser').
:- comment(author, "John Fletcher, ECLiPSe wrapper by Joachim Schimpf").
:- comment(copyright, "Copyright (C) 2001-2005 Binding Time Limited, 2005,2006 John Fletcher").
:- comment(desc, html("\n<h2>Note for ECLiPSe users</h2>\n<p>\nThis code creates and accepts character lists rather than ECLiPSe strings. \nTo convert between character lists and (UTF8 or ASCII) strings, use the\nECLiPSe built-in string_list/3. For example, to parse a UTF-8 encoded\nXML file, use the following code:\n</p><pre>\nxml_parse_file(File, Document) :-\n\topen(File, read, Stream),\n\tread_string(Stream, end_of_file, _, Utf8String),\n\tclose(Stream),\n\tstring_list(Utf8String, Chars, utf8),\n\txml_parse(Chars, Document).\n</pre><p>\nThis is Revision 2.0 of John Fletcher's code.\nMost of the subsequent text is taken literally from\n<a href=\"http://www.binding-time.co.uk/xmlpl.html\">\nhttp://www.binding-time.co.uk/xmlpl.html</a>.\n</p>\n\n<h2>TERMS AND CONDITIONS</h2>\n<p>\nThis program is offered free of charge, as unsupported source code. You may\nuse it, copy it, distribute it, modify it or sell it without restriction,\nbut entirely at your own risk.\n</p><p>\nWe hope that it will be useful to you, but it is provided \"as is\" without\nany warranty express or implied, including but not limited to the warranty\nof non-infringement and the implied warranties of merchantability and fitness\nfor a particular purpose.\n</p>\n<pre>\nHistory:\n$Log: xml_comments.ecl,v $\nRevision 1.4  2009/07/16 09:11:23  jschimpf\nMerged patches_6_0 branch up to merge_2009_07_16\n\nRevision 1.3.2.2  2009/04/09 02:11:38  jschimpf\nUpdated the url in documentation\n\nRevision 1.3.2.1  2009/02/19 06:26:40  jschimpf\nAdded comment(categories,...) annotations for better documentation\n\nRevision 1.3  2006/10/17 22:06:22  jschimpf\nReinserted lost licensing paragraph.\n\nRevision 1.2  2006/10/17 22:02:21  jschimpf\nUpgraded to John Fletcher's revision 2.0, released 2006/06/18,\navailable at http://www.zen37763.zen.co.uk/xml_download.html\n\nRevision 1.1  2003/03/31 13:58:02  js10\nUpgraded to latest version from John Fletcher's web site\n\nRevision 1.2  2002/03/26 22:56:55  js10\nAdded John Fletcher's public domain XML parser/generator\n\nRevision 1.1  2002/03/26 22:50:07  js10\nAdded John Fletcher's public domain XML parser/generator\n</pre>\n\n  <h2>Background</h2>\n  <p>xml.pl is a module for parsing <acronym title=\"eXtensible Markup Language\">XML</acronym> with Prolog, which provides\nProlog applications with a simple \"Document Value Model\"\ninterface to XML documents. It has been used successfully in a number of applications.</p>\n  <p>It supports a subset of XML suitable\nfor XML Data and Worldwide Web applications. It is not as strict nor as\ncomprehensive as the <a href=\"http://www.w3.org/TR/2000/REC-xml-20001006\">XML 1.0 Specification</a> mandates.</p>\n  <p>It is not as strict, because, while the\nspecification must eliminate ambiguities, not all errors need to be regarded as\nfaults, and some reasonable examples of real XML usage would have to be\nrejected if they were.</p>\n  <p>It is not as comprehensive, because,\nwhere the XML specification makes provision for more or less complete <acronym title=\"Document Type Declaration\">DTD</acronym>s to be provided as part of a\ndocument, xml.pl actions the local definition of ENTITIES only. Other <acronym title=\"Document Type Declaration\">DTD</acronym> extensions are treated as\ncommentary.</p>\n  <p>\n   <a href=\"http://www.binding-time.co.uk/xml_download.html\">The code, and a\nsmall Windows application which embodies it</a>, has been placed into the public domain, to\nencourage the use of Prolog with XML.</p>\n  <p>I hope that they will be useful to\nyou, but they are not supported, and they are provided without any warranty of any kind.</p>\n  <h2>Specification</h2>\n  <p>Three predicates are exported by the\nmodule: <abbr>xml_parse/[2,3]</abbr>, <abbr>xml_subterm/2</abbr> and <abbr>xml_pp/1.</abbr></p>\n  <p>\n   <dfn>xml_parse( {+Controls}, +?Chars,\n?+Document )</dfn> parses <var>Chars</var>, a list of character codes,\nto/from a data structure of the form <code>\nxml(<span class=\"Nested BNF\">\n&lt;attributes&gt;</span>, <span class=\"Nested BNF\">\n&lt;content&gt;</span>)\n</code> , where:</p>\n  <p>\n   <span class=\"BNF\">\n    \n&lt;attributes&gt;\n   </span> is a list of <span class=\"BNF\">\n\n&lt;name&gt;</span>=<span class=\"BNF\">\n&lt;char data&gt;</span>\n attributes from the (possibly implicit) XML signature of the\ndocument.</p>\n  <p>\n   <span class=\"BNF\">\n    \n&lt;content&gt;\n   </span> is a (possibly empty) list comprising occurrences of :</p>\n  <dl>\n   <dt>\n    <code>\npcdata(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>)\n</code>\n   </dt>\n   <dd>Text</dd>\n   <dt>\n    <code>\ncomment(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>)\n</code>\n   </dt>\n   <dd>An xml comment;</dd>\n   <dt>\n    <code>\nnamespace(<span class=\"Nested BNF\">\n&lt;URI&gt;</span>,<span class=\"Nested BNF\">\n&lt;prefix&gt;</span>,<span class=\"Nested BNF\">\n&lt;element&gt;</span>)\n</code>\n   </dt>\n   <dd>a Namespace</dd>\n   <dt>\n    <code>\nelement(<span class=\"Nested BNF\">\n&lt;tag&gt;</span>, <span class=\"Nested BNF\">\n&lt;attributes&gt;</span>, <span class=\"Nested BNF\">\n&lt;content&gt;</span>)\n</code>\n   </dt>\n   <dd>\n    <span class=\"BNF\">\n     \n&lt;tag&gt;..&lt;/tag&gt;\n    </span> encloses <span class=\"BNF\">\n&lt;content&gt;</span> or <span class=\"BNF\">\n&lt;tag /&gt;</span> if empty.</dd>\n   <dt>\n    <code>\ninstructions(<span class=\"Nested BNF\">\n&lt;name&gt;</span>, <span class=\"Nested BNF\">\n&lt;char data&gt;</span>)\n</code>\n   </dt>\n   <dd>A PI  \n&lt;?<span class=\"BNF\">\n&lt;name&gt;</span><span class=\"BNF\">\n&lt;char data&gt;</span>\n?&gt;</dd>\n   <dt>\n    <code>\ncdata(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>)\n</code>\n   </dt>\n   <dd>&lt;![CDATA[<span class=\"BNF\">\n&lt;char data&gt;</span>]]&gt;\n</dd>\n   <dt>\n    <code>\ndoctype(<span class=\"Nested BNF\">\n&lt;tag&gt;</span>, <span class=\"Nested BNF\">\n&lt;doctype id&gt;</span>)\n</code>\n   </dt>\n   <dd>\n    \nDTD &lt;!DOCTYPE .. &gt;\n   </dd>\n  </dl>\n  <p>The conversions are not completely\nsymmetrical, in that weaker XML is accepted than can be generated.\nSpecifically, in-bound <em>(Chars -&gt;\nDocument)</em> parsing does not require strictly well-formed XML. If <var>Chars</var> does not represent well-formed\nXML, <var>Document</var> is instantiated\nto the term <code>malformed(<span class=\"Nested BNF\">\n&lt;attributes&gt;</span>, <span class=\"Nested BNF\">\n&lt;content&gt;</span>)\n\n\n</code> .</p>\n  <p>The <span class=\"BNF\">\n&lt;content&gt;</span> of a <abbr>malformed/2</abbr>\nstructure can include:</p>\n  <dl>\n   <dt>\n    <code>\nunparsed( <span class=\"Nested BNF\">\n&lt;char data&gt;</span> )\n</code>\n   </dt>\n   <dd>Text which has not been parsed</dd>\n   <dt>\n    <code>\nout_of_context( <span class=\"Nested BNF\">\n&lt;tag&gt;</span> )\n</code>\n   </dt>\n   <dd>\n    <span class=\"BNF\">\n     \n&lt;tag&gt;\n    </span> is not closed\n</dd>\n  </dl>\n  <p>in addition to the parsed term\ntypes.</p>\n  <p>Out-bound <em>(Document -&gt; Chars)</em> parsing <em>does</em> require that <var>Document</var> defines well-formed XML. If\nan error is detected a 'domain' exception is raised.</p>\n  <p>The domain exception will attempt to\nidentify the particular sub-term in error and the message will show a list of\nits ancestor elements in the form <span class=\"BNF\">\n&lt;tag&gt;{(id)}*</span> where <span class=\"BNF\">\n\n&lt;id&gt;\n</span> is the value of any attribute <em>named</em> id.</p>\n  <p>At this release, the <var>Controls</var> applying\nto in-bound <em>(Chars -&gt;\nDocument)</em> parsing are:</p>\n  <dl>\n   <dt>\n    <code>\nextended_characters(<span class=\"Nested BNF\">\n&lt;bool&gt;</span>)\n</code>\n   </dt>\n   <dd>Use the extended character entities for XHTML (default true).</dd>\n   <dt>\n    <code>\nformat(<span class=\"Nested BNF\">\n&lt;bool&gt;</span>)\n</code>\n   </dt>\n   <dd>Remove layouts\nwhen no non-layout character data appears between elements (default true).</dd>\n   <dt>\n    <code>\nremove_attribute_prefixes(<span class=\"Nested BNF\">\n&lt;bool&gt;</span>)\n</code>\n   </dt>\n   <dd>Remove redundant prefixes from attributes - i.e. prefixes\n   denoting the namespace of the parent element (default false).</dd>\n   <dt>\n    <code>\nallow_ampersand(<span class=\"Nested BNF\">\n&lt;bool&gt;</span>)\n</code>\n   </dt>\n   <dd>Allow unescaped ampersand characters (&amp;) to occur in PCDATA\n(default false).</dd>\n  </dl>\n  <p>For out-bound <em>(Document -&gt; Chars)</em> parsing, the\nonly available option is:</p>\n  <dl>\n   <dt>\n    <code>\nformat(<span class=\"Nested BNF\">\n&lt;bool&gt;</span>)\n</code>\n   </dt>\n   <dd>Indent the element content, (default true)</dd>\n  </dl>\n  <h3>Types</h3>\n  <dl>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;tag&gt;\n    </span>\n   </dt>\n   <dd>An atom naming an element</dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;name&gt;\n    </span>\n   </dt>\n   <dd>An atom, not naming an element</dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;URI&gt;\n    </span>\n   </dt>\n   <dd>An atom giving the URI of a Namespace</dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;char data&gt;\n    </span>\n   </dt>\n   <dd>A \"string\": list of character codes.</dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;doctype id&gt;\n    </span>\n   </dt>\n   <dd>one of <code>\npublic(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>, <span class=\"Nested BNF\">\n&lt;char data&gt;</span>)\n</code>,\n<code>public(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>,\n<span class=\"Nested BNF\">\n&lt;char data&gt;</span>,\n<span class=\"Nested BNF\">\n&lt;dtd literals&gt;</span>)</code>,\n<code>system(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>)</code>,\n<code>system(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>,\n<span class=\"Nested BNF\">\n&lt;dtd literals&gt;</span>)</code>,\n<code>local</code> or <code>local(<span class=\"Nested BNF\">\n&lt;dtd literals&gt;</span>)</code></dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;dtd literals&gt;\n    </span>\n   </dt>\n   <dd>A non-empty list of\n\t<code>dtd_literal(<span class=\"Nested BNF\">\n&lt;char data&gt;</span>)</code> terms - e.g. <a href=\"http://www.w3.org/TR/2000/REC-xml-20001006#NT-AttlistDecl\">attribute-list\ndeclarations</a>.</dd>\n   <dt>\n    <span class=\"BNF\">\n     \n&lt;bool&gt;\n    </span>\n   </dt>\n   <dd>one of <code>true</code>\nor <code>false</code></dd>\n  </dl>\n  <p>\n   <dfn>xml_subterm( +XMLTerm, ?Subterm )</dfn> unifies <var>Subterm</var>\n   with a sub-term\nof <var>Term</var>. This can be especially\nuseful when trying to test or retrieve a deeply-nested subterm from a document\n- as demonstrated in this <a href=\"http://www.binding-time.co.uk/xml_example.html\">example program</a>.\nNote that <var>XMLTerm</var> is a sub-term of itself.</p>\n  <p>\n   <dfn>xml_pp( +XMLDocument )</dfn>&nbsp;\"pretty\nprints\" <var>XMLDocument</var> on the\ncurrent output stream.</p>\n  <h2>Availability</h2>\n  <p>The module is available from <a href=\"http://www.binding-time.co.uk/xml_download.html\">this site</a>, and is supplied as a library with the following Prologs:</p>\n  <ul>\n   <li>It is available in the <a href=\"http://eclipse-clp.org\">ECLiPSe Constraint Programming System</a>, as a\nthird-party library;</li>\n   <li>It has been ported to <a href=\"http://www.probp.com/\">B-Prolog</a>\nby Neng-Fa Zhou.</li>\n   <li>It has been adapted for <a href=\"http://www.sics.se/sicstus/\">SICStus Prolog</a> version <a href=\"http://www.sics.se/sicstus/docs/latest/html/relnotes.html/3.11.0-Changes.html\">3.11+</a>\nby Mats Carlsson.</li>\n   <li>It is included in <a href=\"http://www.sics.se/isl/quintuswww/site/rel-history.html\">Quintus Prolog Release 3.5</a>.</li>\n  </ul>\n  <h2>Features of xml.pl</h2>\n  <p>The <code>xml/2</code> data structure has some useful properties.</p>\n  <h3>Reusability</h3>\n  <p>Using an \"abstract\" Prolog\nrepresentation of XML, in which terms represent document \"nodes\", makes the\nparser reuseable for any XML application.</p>\n  <p>In effect, xml.pl encapsulates the\napplication-independent tasks of document parsing and generation, which is\nessential where documents have components from more than one Namespace.</p>\n  <h3>Same Structure</h3>\n  <p>The Prolog term representing a document\nhas the same structure as the document itself, which makes the correspondence\nbetween the literal representation of the Prolog term and the XML source\nreadily apparent.</p>\n  <p>For example, this simple <a href=\"http://www.w3.org/Graphics/SVG/Overview.htm8\"><acronym title=\"Scalable Vector Graphics\">SVG</acronym></a> image:</p>\n  <pre>   \n&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;\n&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.0//EN\" \"http://www.w3.org/.../svg10.dtd\"\n    [\n    &lt;!ENTITY redblue \"fill: red; stroke: blue; stroke-width: 1\"&gt;\n    ]&gt;\n&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"500\" height=\"500\"&gt;\n &lt;circle cx=\" 25 \" cy=\" 25 \" r=\" 24 \" style=\"&amp;redblue;\"/&gt;\n&lt;/svg&gt;\n  </pre>\n  <p>... translates into this Prolog\nterm:</p>\n  <pre>   \nxml( [version=\"1.0\", standalone=\"no\"],\n    [\n    doctype( svg, public( \"-//W3C//DTD SVG 1.0//EN\", \"http://www.w3.org/.../svg10.dtd\" ) ),\n    namespace( 'http://www.w3.org/2000/svg', \"\",\n        element( svg,\n            [width=\"500\", height=\"500\"],\n            [\n            element( circle,\n                [cx=\"25\", cy=\"25\", r=\"24\", style=\"fill: red; stroke: blue; stroke-width: 1\"],\n                [] )\n            ] )\n        )\n    ] ).\n  </pre>\n  <h3>Efficient Manipulation</h3>\n  <p>Each type of node in an XML document is\nrepresented by a different Prolog functor, while data, (PCDATA, CDATA and\nAttribute Values), are left as \"strings\", (lists of character codes).</p>\n  <p>The use of distinct functors for\nmark-up structures enables the efficient recursive traversal of a document,\nwhile leaving the data as strings facilitates application-specific parsing of\ndata content (aka <a href=\"http://www.google.com/search?q=%22Micro-parsing%22+XML\">Micro-parsing</a>).</p>\n  <div id=\"cdata_to_pcdata\" class=\"Predicate\">\n   <p>For example, to turn every CDATA node\ninto a PCDATA node with tabs expanded into spaces:</p>\n   <pre>    \ncdata_to_pcdata( cdata(CharsWithTabs), pcdata(CharsWithSpaces) ) :-\n    tab_expansion( CharsWithTabs, CharsWithSpaces ).\ncdata_to_pcdata( xml(Attributes, Content1), xml(Attributes, Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( namespace(URI,Prefix,Content1), namespace(URI,Prefix,Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( element(Name,Attrs,Content1), element(Name,Attrs,Content2) ) :-\n    cdata_to_pcdata( Content1, Content2 ).\ncdata_to_pcdata( [], [] ).\ncdata_to_pcdata( [H1|T1], [H2|T2] ) :-\n    cdata_to_pcdata( H1, H2 ),\n    cdata_to_pcdata( T1, T2 ).\ncdata_to_pcdata( pcdata(Chars), pcdata(Chars) ).\ncdata_to_pcdata( comment(Chars), comment(Chars) ).\ncdata_to_pcdata( instructions(Name, Chars), instructions(Name, Chars) ).\ncdata_to_pcdata( doctype(Tag, DoctypeId), doctype(Tag, DoctypeId) ).\n   </pre>\n  </div>\n  <p>The above uses no 'cuts', but will not\ncreate any choice points with ground input.</p>\n  <h3>Elegance</h3>\n  <p>The resolution of entity references and\nthe decomposition of the document into distinct nodes means that the calling\napplication is not concerned with the occasionally messy syntax of XML\ndocuments.</p>\n  <p>For example, the clean separation of\nnamespace nodes means that Namespaces, which are useful in combining\nspecifications developed separately, have similar usefulness in combining\napplications developed separately.</p>\n  <p>\n   <a href=\"http://www.binding-time.co.uk/xml_download.html\">The source code is available here</a>.\nAlthough it is unsupported, please feel free to <a href=\"mailto:john_fletcher@tesco.net\">e-mail queries and suggestions</a>. I\nwill respond as time allows.</p>\n")).
:- comment(xml_parse / 2, [summary : "Parse or generate XML documents", amode : xml_parse(+, -), amode : xml_parse(-, +), args : ["Chars" : "List of characters", "Document" : "Document as structured term"], see_also : [xml_parse / 3, xml_subterm / 2, xml_pp / 1]]).
:- comment(xml_parse / 3, [summary : "Parse or generate XML documents", amode : xml_parse(+, +, -), amode : xml_parse(+, -, +), args : ["Controls" : "List of options", "Chars" : "List of characters (XML text)", "Document" : "Document as structured term"], see_also : [xml_parse / 2], desc : ascii("\nxml_parse( {+Controls}, +?Chars, ?+Document ) parses Chars to/from a data\nstructure of the form xml(<atts>, <content>). <atts> is a list of\n<atom>=<string> attributes from the (possibly implicit) XML signature of the\ndocument. <content> is a (possibly empty) list comprising occurrences of :\n\npcdata(<string>)\t\t:\tText\ncomment(<string>)\t\t:\tAn xml comment;\nelement(<tag>,<atts>,<content>)\t:\t<tag>..</tag> encloses <content>\n\t\t\t\t:       <tag /> if empty\ninstructions(<atom>, <string>)\t:\tProcessing <? <atom> <params> ?>\ncdata( <string> )\t\t:\t<![CDATA[ <string> ]]>\ndoctype(<atom>, <doctype id>)\t:\tDTD <!DOCTYPE .. >\n\nThe conversions are not completely symmetrical, in that weaker XML is\naccepted than can be generated. Specifically, in-bound (Chars -> Document)\ndoes not  require strictly well-formed XML. Document is instantiated to the\nterm malformed(Attributes, Content) if Chars does not represent well-formed\nXML. The Content of a malformed/2 structure can contain:\n\nunparsed( <string> )\t\t:\tText which has not been parsed\nout_of_context( <tag> )\t\t:\t<tag> is not closed\n\nin addition to the standard term types.\n\nOut-bound (Document -> Chars) parsing _does_ require that Document defines\nstrictly well-formed XML. If an error is detected a 'domain' exception is\nraised.\n\nThe domain exception will attempt to identify the particular sub-term in\nerror and the message will show a list of its ancestor elements in the form\n<tag>{(id)}* where <id> is the value of any attribute _named_ id.\n\nAt this release, the Controls applying to in-bound (Chars -> Document)\nparsing are:\n\nextended_characters(<bool>)\t    :\tUse the extended character\n\t\t\t\t    :\tentities for XHTML (default true)\n\nformat(<bool>)\t\t\t    :\tStrip layouts when no character data\n\t\t\t\t    :\tappears between elements.\n\t\t\t\t    :\t(default true)\n\nremove_attribute_prefixes(<bool>)   :  Remove namespace prefixes from\n                                    :  attributes when it's the same as the\n                                    :  prefix of the parent element\n                                    :  (default false).\n\nallow_ampersand(<bool>)             :  Allow unescaped ampersand\n                                    :  characters (&) to occur in PCDATA.\n                                    :  (default false).\n\n[<bool> is one of 'true' or 'false']\n\nFor out-bound (Document -> Chars) parsing, the only available option is:\n\nformat(<Bool>)\t\t\t    :\tIndent the element content\n\t\t\t\t    :\t(default true)\n\nDifferent DCGs for input and output are used because input parsing is\nmore flexible than output parsing. Errors in input are recorded as part\nof the data structure. Output parsing throws an exception if the document\nis not well-formed, diagnosis tries to identify the specific culprit term.\n")]).
:- comment(xml_pp / 1, [summary : "Pretty-prints XMLDocument on the current output stream", amode : xml_pp(+), args : ["XMLDocument" : "Document as structured term"], see_also : [xml_parse / 2, xml_parse / 3, xml_subterm / 2]]).
:- comment(xml_subterm / 2, [summary : "Unifies Subterm with a sub-term of Term.", amode : xml_subterm(+, ?), args : ["XMLTerm" : "Structured term", "Subterm" : "Structured term"], desc : html("\n    This can be especially useful when trying to test or retrieve a\n    deeply-nested subterm from a document - as demonstrated in this\n    <a href=\"http://www.binding-time.co.uk/xml_example.html\">example\n    program</a>.  Note that <code>XMLTerm</code> is a sub-term of itself."), see_also : [xml_parse / 2, xml_parse / 3, xml_pp / 1]]).
