:- module(list_collection).
:- export create / 2.
:- export append_element / 3.
:- export append_list / 3.
:- export prefix_element / 3.
:- export prefix_list / 3.
:- export get_list / 3.
:- export terminate_and_get_list / 3.
:- export terminate_all_lists / 2.
:- export get_indexes / 2.
:- export reinit / 2.
:- comment(categories, ["Data Structures"]).
:- comment(summary, "Collection of lists library").
:- comment(author, "Lukasz Domagala").
:- comment(copyright, "Silesian University of Technology").
:- comment(date, "$Date: 2009/07/16 09:11:23 $").
:- comment(desc, ascii("\r\n    A library for creation and management of list collections (LCOL).\r\n    Internally the library uses either the a hashtable or arrays to store lists and their tails. \r\n    The advantage of a hash LCOL is that its size does not have to be known in advance and that \r\n    non number indexes can be used to address lists in the collection. The drawback of a hash LCOL \r\n    is that access to collection elements is slower than for array LCOL. Elements of array LCOL \r\n    can be addressed only by positive integers which internally are array indexes. See create/2 \r\n    for more details.\r\n    \r\n    The motivation for creating this library was to be able to easily build input lists for global \r\n    constraints from collections of input structures (see example). For this purpose an array(3) LCOL \r\n    was usually sufficient, and only a limited set of predicates needed (create/2 , append_element/3, \r\n    terminate_all_lists/2, get_list/3).\r\n    \r\n    But the idea was extended, additional predicates were added for prefixing the lists, and \r\n    reinitialisation of lists. The support for hash LCOL has been added. Hash LCOL may be useful for \r\n    some filtering, grouping predicates in cases when the number of lists may vary or indexing by \r\n    atoms/ground terms is more readable/convenient.\r\n\r\n    ")).
:- comment(eg, "\r\nllcol_example:-\r\n    lib(ic),\r\n    lib(ic_edge_finder),\r\n\r\n    ActivityList=[\r\n        act(4,7 ,2,machine_1),\r\n        act(3,4 ,1,machine_2 ),\r\n        act(2,4 ,2,removed),\r\n        act(7,10,1,machine_1),\r\n        act(6,15,3,machine_3)\r\n        % ...\r\n    ],\r\n    \r\n    %create a collection of activity lists for corresponding machines\r\n    list_collection:create(hash,LCOL_Machines),\r\n    \r\n    %sort the activities for machines\r\n    (foreach(Activity,ActivityList),\r\n     param(LCOL_Machines) do \r\n        Activity=act(_Start,_End,_Resource,Machine),\r\n        (Machine \\= removed ->\r\n            %add an activity to the list for the particular machine\r\n            list_collection:append_element(LCOL_Machines,Machine,Activity)\r\n        ;true)\r\n    ),\r\n    \r\n    %close the lists get the machine names\r\n    list_collection:terminate_all_lists(LCOL_Machines,Machines_Indexes),\r\n    \r\n    %for each machine\r\n    (foreach(Machines_Index,Machines_Indexes),\r\n     param(LCOL_Machines) do \r\n        %Note that get_list/3 can be used even if the lists are not terminated but in such a case the operation\r\n        %is more time consuming, because all the list elements are copied to new closed list and then returned.\r\n        %Instead of closing all the lists at once it is also possible to use terminate_and_get_list/3 to ensure \r\n        %that the list is closed.\r\n        \r\n        %get the activity list for the machine\r\n        list_collection:get_list(LCOL_Machines,Machines_Index,MActivityList),\r\n        \r\n        %create a collection for start,duration and resource variable lists\r\n        list_collection:create(array(3),LCOL_Start_Dur_Res),\r\n        \r\n        (foreach(MActivity,MActivityList),\r\n         param(LCOL_Start_Dur_Res) do\r\n         \r\n            MActivity=act(Start,End,Resource,_Machine),\r\n            ic:(Duration #= End - Start),\r\n            list_collection:append_element(LCOL_Start_Dur_Res, 1, Start),\r\n            list_collection:append_element(LCOL_Start_Dur_Res, 2, Duration),\r\n            list_collection:append_element(LCOL_Start_Dur_Res, 3, Resource)\r\n        ),\r\n        \r\n        %terminate the start,duration,resource lists\r\n        list_collection:terminate_all_lists(LCOL_Start_Dur_Res,_Indexes),\r\n        \r\n        %get the lists for a cumulative constraint\r\n        list_collection:get_list(LCOL_Start_Dur_Res, 1, StartList),\r\n        list_collection:get_list(LCOL_Start_Dur_Res, 2, DurationList),\r\n        list_collection:get_list(LCOL_Start_Dur_Res, 3, ResourceList),\r\n\r\n        %post the constraint\r\n        ic_edge_finder:cumulative(StartList, DurationList, ResourceList, 3)\r\n    ).\r\n    ").
:- comment(append_element / 3, [amode : (append_element(+, ++, +) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "Elem" : "Term or variable"], summary : "Append an Elem to the internal list identified by Index.", desc : "Complexity O(1).", see_also : [append_list / 3, prefix_element / 3, prefix_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground.", 1 : "List identified by Index is closed."]]).
:- comment(append_list / 3, [amode : (append_list(+, ++, +) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "List" : "A list of terms or variables"], summary : "Append a List to the internal list identified by Index.", desc : "Complexity O(|List|).", see_also : [append_element / 3, prefix_element / 3, prefix_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground.", 1 : "List identified by Index is closed."]]).
:- comment(create / 2, [amode : (create(++, -) is det), args : ["Type" : "A ground term", "LCOL" : "A list collection"], summary : "Creates a list collection", desc : ascii("\r\n        If (Type==hash) a LCOL internally uses a hashtable, this is useful when the number of lists is unknown.\r\n        If (Type=array(Size)) where Size is a natural number, the LCOL internally uses an array to collect lists,\r\n        the access to any of the lists is faster, but the Size has to be known in advance and only number \r\n        indexes can be used to identify lists. 0<Index=<Size."), see_also : [append_element / 3, terminate_all_lists / 2, get_list / 3], exceptions : [5 : "Not supported Type."]]).
:- comment(get_indexes / 2, [amode : (get_indexes(+, -) is det), args : ["LCOL" : "A list collection", "Indexes" : "List of indexes"], summary : "Retrieves the list of indexes", desc : "Complexity O(ListCount).", see_also : [get_list / 3, terminate_and_get_list / 3, terminate_all_lists / 2], exceptions : [5 : "LCOL is not a list collection."]]).
:- comment(get_list / 3, [amode : (get_list(+, ++, -) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "List" : "A list of terms"], summary : "Retrieves the list of elements identified by Index", desc : "If the internal list identified by Index is open, the elements from the list are copied to a closed List and returned. The internal list remains open. Complexity O(|List|).\r\n            If the internal list identified by Index is closed, the internal list is returned immediately as List. Complexity O(1).", see_also : [terminate_all_lists / 2, terminate_and_get_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground."]]).
:- comment(prefix_element / 3, [amode : (prefix_element(+, ++, +) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "Elem" : "Term or variable"], summary : "Prefixes the internal list identified by Index with an Elem.", desc : " Complexity O(1)", see_also : [append_element / 3, append_list / 3, prefix_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground."]]).
:- comment(prefix_list / 3, [amode : (prefix_list(+, ++, +) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "List" : "A list of terms or variables"], summary : "Prefixes the internal list identified by Index with a List.", desc : "Complexity O(|List|).", see_also : [append_element / 3, append_list / 3, prefix_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground."]]).
:- comment(reinit / 2, [amode : (reinit(+, ++) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number"], summary : "Creates a new list identified by Index", desc : "Discards the internal list of elements identified by Index, and replaces with a new list. Complexity O(1).", see_also : [terminate_all_lists / 2, terminate_and_get_list / 3], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground."]]).
:- comment(terminate_all_lists / 2, [amode : (terminate_all_lists(+, -) is det), args : ["LCOL" : "A list collection", "Indexes" : "List of indexes"], summary : "Terminates all internal lists in the collection, and gets the list of indexes", desc : "Complexity O(ListCount).", see_also : [get_list / 3, terminate_and_get_list / 3, reinit / 2, get_indexes / 2], exceptions : [5 : "LCOL is not a list collection."]]).
:- comment(terminate_and_get_list / 3, [amode : (terminate_and_get_list(+, ++, -) is det), args : ["LCOL" : "A list collection", "Index" : "A ground term or number", "List" : "A list of terms"], summary : "Retrieves the List of elements identified by Index", desc : "Ensures that the internal List of elements identified by Index is terminated, and returns the internal List. Complexity O(1).", see_also : [get_list / 3, terminate_all_lists / 2, reinit / 2], exceptions : [5 : "LCOL is not a list collection.", 5 : "Index is not a number or is out of range.", 5 : "Index is not ground."]]).
